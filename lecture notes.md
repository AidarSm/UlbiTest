# Нюансы

- undefind-неопределенность ,данный тип данный выводиться когда переменная неопределена, ей не присвоено значение
- null -выводиться когда строка пустая, при методе typeof выводитья object это ошибка.
- при использование режима 'use strict' обьявления переменной без let вызовет ошибку, myAge=10// Error;
- отличия var от let, var мы можем использовать до ее обьявления, и это не вызовет ошибку
  область видимости var ограничиваеться только функцией, в циклах и условиях ее видно и за блоком. Функционлаьная область фидимости, а у let и const блочная область видимости.
- При использользование математического оператора '+' сложения строк происходит 10+'10'='1010',
  при использование остальных операторов идет приобразование в числовой тип '10'\*'10'=100, если в строках идут слова то значение выдаст NaN.
  Если беред строкой где накодиться число поставить '+',то строка поменяет тип данных на number(console.log(+'10'+ +'10');//20)
- При использовани оператора сравнения равно '==' аргументы переводяться в числа
- Логический оператор 'или' || выводит первое найденое true или последние false
  логический оператор 'и' && выводит первое найденое false или последние true (имеет большую приоритетность чем ||)
-

# CSS

### Flex

Для контейнера (flex container):
display: flex; — превращает элемент в flex контейнер.
flex-direction: row | row-reverse | column | column-reverse; — определяет направление главной оси (основной оси, по которой располагаются элементы).
flex-wrap: nowrap | wrap | wrap-reverse; — определяет, должны ли элементы переноситься на новую строку, если они не помещаются в одну строку.
flex-flow: <flex-direction> || <flex-wrap>; — сокращенное свойство для установки flex-direction и flex-wrap одновременно.
justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly; — выравнивает элементы по главной оси.
align-items: flex-start | flex-end | center | baseline | stretch; — выравнивает элементы по поперечной оси.
align-content: flex-start | flex-end | center | space-between | space-around | stretch; — выравнивает строки или строки контейнера, если они занимают больше пространства, чем доступное.
Для элементов (flex items):
order: <integer>; — определяет порядок, в котором элементы появляются в контейнере.
flex-grow: <number>; — определяет, насколько элемент должен расти, если в контейнере есть свободное пространство.
flex-shrink: <number>; — определяет, насколько элемент должен сжиматься, если в контейнере не хватает пространства.
flex-basis: <length> | auto; — определяет начальный размер элемента перед распределением свободного пространства.
flex: none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]; — сокращенное свойство для установки flex-grow, flex-shrink и flex-basis одновременно.
align-self: auto | flex-start | flex-end | center | baseline | stretch; — позволяет переопределить выравнивание элемента, установленное для всех элементов контейнера.

### Grid

Для контейнера (grid container):
display: grid; — превращает элемент в контейнер сетки.
grid-template-columns: <track-size> ...; — определяет количество и размеры столбцов сетки.
grid-template-rows: <track-size> ...; — определяет количество и размеры строк сетки.
grid-template-areas: "header header header" "sidebar main main" "footer footer footer"; — позволяет определить области сетки и их расположение.
grid-template: <grid-template-rows> / <grid-template-columns>; — сокращенное свойство для установки grid-template-rows и grid-template-columns одновременно.
grid-auto-rows: <track-size>; — определяет размер строк, которые автоматически создаются при необходимости.
grid-auto-columns: <track-size>; — определяет размер столбцов, которые автоматически создаются при необходимости.
grid-auto-flow: row | column | dense; — определяет, как автоматически размещаются элементы сетки, которые не помещаются в явно определенные ячейки.
Для элементов (grid items):
grid-column: <start-line> / <end-line>; — определяет, в какие столбцы элемент должен быть размещен.
grid-row: <start-line> / <end-line>; — определяет, в какие строки элемент должен быть размещен.
grid-area: <grid-area-name>; — позволяет разместить элемент в определенной области сетки.
justify-self: start | end | center | stretch; — выравнивает элемент по горизонтали внутри своей ячейки.
align-self: start | end | center | stretch; — выравнивает элемент по вертикали внутри своей ячейки.

### @Keyframes

Свойства, связанные с @keyframes:
animation-name — указывает имя анимации, которую нужно применить.
animation-duration — определяет продолжительность анимации.
animation-timing-function — задает скорость анимации.
animation-delay — задает задержку перед началом анимации.
animation-iteration-count — определяет, сколько раз анимация должна повторяться.
animation-direction — определяет, должна ли анимация воспроизводиться в обратном порядке.
animation-fill-mode — определяет стили элемента до и после анимации.
animation-play-state — позволяет приостановить или возобновить анимацию.

### transition

transition-property — указывает, какие свойства должны анимироваться.
transition-duration — определяет продолжительность анимации.
transition-timing-function — задает скорость анимации.
transition-delay — задает задержку перед началом анимации.
Синтаксис transition:
transition: <property> <duration> <timing-function> <delay>;

# Лекция DOM=======================

```javascript
alert('Привет красавчик '); //выводит в окно бразуера текст

constConfirm = confirm('You Gay?'); //выводит текст в варантов ответов ок или отмена возвращает true или false
console.log(confirmResult);

constPromt = promt('You Gay?'); //выводит текст с возможностью ввести ответ, если ничего не вводишь то ничег не приходит
console.log(constPromt);

//НАВИГАЦИЯ ПО ДЕРЕВУ ДОМ
const htmlElement = document.documentElement; //получаем элемент html со всем содержимым
const headElement = document.head; //получаем элемент head со всем содержимым
const bodyElement = document.body; //получаем элемент body со всем содержимым
const firstChildNodes = bodyElement.firstChild; //получаем первый дочерний узел элемента, надо учесть что пробелы тоже считатються за узлы
const firstChildNodes = bodyElement.firstChild; //получаем последний дочерний узел элемента
const childNodes = bodyElement.childNodes; //выводит коллекцию всех дочерних узлов ,включая текстовые узлы(символ первода строки или что-то в этом роде). Коллекция это псевдомассив, можно испольщовать метод перебора for of, однако другие нельзя.Почти все DOM коллекциии "живые" и реально отражают состояния дерева DOM
bodyElement.hasChildNodes(); //проверяет есть ли у элемента дочерние узлы ,выводит boolean type.

bodyElement.previousSibling; //чтобы получить предудщий узел объекта которые находиться на том же уровне вложенности;
bodyElement.nextSibling; //чтобы получить следующий узел объекта которые находиться на том же уровне вложенности;
bodyElement.parentNode; // чтобы получить родителя объекта

//Получаем только узлы-элементы, без текстовых узлов
bodyElement.previousElementSibling; //чтобы получить предудщий узел объекта которые находиться на том же уровне вложенности;
bodyElement.nextElementSibling; //чтобы получить следующий узел объекта которые находиться на том же уровне вложенности;
bodyElement.parentElement; // чтобы получить родителя объекта
bodyElement.children; //получем коллекцию дочерних узлов-элементов
bodyElement.firstElementChild; //получаем первый дочерний узел-элемент
bodyElement.lastElementChild; //получаем последний дочерний узел-элемент

//ПОИСК ПО ДЕРЕВУ ДОМ
//querySelectorAll вовзращает СТАТИЧНУЮ(содержит информацию на момент вызова поиска) коллекцию
//elems[2] //получаем третий элемент в коллекции
//for (const item elems){console.log(item)}- перебираем коллекцию
//elems.forEach(item=>cosole.log(item))- перебираем коллекцию
const elems = document.querySelectorAll('.lesson__list'); //селектор класса
('li'); // селектор тега
('li.lesson__list'); //по смешенном селектору тега и класса
('.lesson__list>li'); //поиск по тегу первого уровня вложенности
('.lesson__list,.lesson__text'); // поиск по нескольки классам
('.lesson__list.lesson__text'); //поиск по вложенным классам (ищем объекты с классом text ,но которые тья внутри объетов с классом list )
('#listItem'); //поиск по id (получим только один объект, так как id должен быть уникальным)
('[data-item]'); //поиск по атрибуту
('[data-item]="85"'); //поиск по атрибуту с конкретным значением

//Искать можно не только в document
elems[0].querySelectorAll('li'); //ищем в первом элементе ,все элементы с тегом li

querySelector; //ищет первый подходящий элемент и в const попадает не коллекция а, только один СТАТИЧНЫЙ  объект

document.getElementById('listItem'); //ищет только в document, получаем СТАТИЧНЫЙ один объект
document.getElementsByTagName('li'); //ищем по имени тека и возвращает ЖИВУЮ(содержит актуальную информацию) коллекцию
document.getElementsByClassName('lesson__list'); // ищем по имени класса, получаем ЖИВУЮ коллекцию
document.getElementsByName('list'); //ищет только в document, получаем ЖИВУЮ коллекцию

elem.closest('.lesson__list'); //ищет ближайшего предка элемента на котором используеться данный метод с соответствующим селектором
elem.matches('.lesson__list'); //ничего не ищет а проверяет, удовлетворят ли элемент CSS-селектору и возвращает true или false

//ИЗМЕНЕНИЕ ДЕРЕВА ДОМ

const textElementContent = elems.innerHTML; // получаем содержимое объекта как есть вместе с HTML
elems.innerHTML = 'you ray'; //Меняем содержимое. При заменен содержимого мы не меняем дерево дом, а меняем только отображение в браузере. Если после изм. вызвать вновь elems.innerHTML то он не поменяеться
const textElementContent = elems.outerHTML; // получаем содержимое объекта как есть вместе с HTML, а также сам элемент
elems.outerHTML = '<p>you ray</p>'; //при замене содержимого мы не меняем дерево дом, а меняем только отображение в браузере. Если после изм. вызвать вновь elems.outerHTML то он не поменяеться
const textElementContent = elems.textContent; //получаем содержимое без HTML
elems.textContent = '<p>you ray</p>'; //<p>you ray</p> получим строку, записываем текст безопасный способом
textElement.nextSibling.data; //получаем содержимое текстового узла/комментария
textElement.nextSibling.data = 'you ray'; //можем менять комментарии

//Создание элементов и узлов
const newElement = document.createElement('div'); //создание элементов и узлов
newElement.innerHTML = 'You ray. <p>AND pay</p>'; //наполняем новый элемент
const newText = document.createTextNode('Привет'); //создание нового текстового узла

//Вставка новосозданного элемента
//Вставка либо готовго объекта или текстового узла, текст с HTML не получиться вставить
textElement.before(newElement, 'Привет'); //вставка перед объектом textElement, можно сразу вставлять несколько объектов в данном случае и объект и текст
textElement.after(newElement); //вставка после  объекта textElement
textElement.prepend(newElement); //вставка внутрь и в начало  объекта textElement
textElement.apppend(newElement); //вставка внутрь и в конец  объекта textElement

//Вставка текста с HTML
textElement.insertAdjacentHTML('afterend', `<p>AND pay</p>`);
textElement.insertAdjacentText('afterend', `AND pay`);
textElement.insertAdjacentElement('afterend', `<div>`);

('beforebegin'); //вставить  html непосредственно перед textElement
('afterbegin'); //вставить  html в начало textElement
('beforeend'); //вставить  html в конец textElement
('afterend'); //вставить  html непосредственно после textElement

//Перенос элемент, осущеставляеться с помощью методов вставки, потом что данные методы автоматичсеки удаляют со старого места
//Если нам надо клонировать объект то мы используем метод cloneNode(), cloneNode(true) глубокое клонирование вместе с содержимым
const cloneTextElement = textElement.cloneNode(); //клонируем
const lessonBlock = document.querySelector('.lesson__text'); //находим элемент относительно которого будем вставлять
lessonBlock.append(cloneTextElement); //вставляем

//Удаление узлов
textElement.remove();//удаляем объект ранее полученный в const

//СТИЛИ И КЛАССЫ -предпочтительный производить манипуляции с classами чем менять style
const element=document.querySelector('.lesson__text');
cosnt elementClassName=element.className;//получаем название классов данного элемента
//обращаемся к элементу с помощью метода classList получаем доступ к атрибуту class, а после используем различные методы
element.classList.add('active');//добавляет класс
element.classList.remove('active');//удаляет класс
element.classList.toggle('active');//добавить класс если его нет, а если есть удалить
element.classList.contains('active');//проврека наличия класс, возвращает true/false
for(let className of element.classList){console.log(className)};//перебираем и выводим в лог все классы элемента

//Задаем стиль с помощью CSS свойства style
element.style.color='red';
element.style.marginBottom='30px';
element.style.zIndex='10';
//Для получаения значения какого-то свойство нам нужно к нему обратиться? если конечно свойство записано в атрибуте style
console.log(element.style.marginBottom);
//Для сброса свойства нужно присвоить пустую строку
element.style.marginBottom='';
//Для записи множества стилей, но он перезаписывает всей свойства в style
element.style.cssText=`
margin-bottom:30px;
color:red;
`
//Получаем вычеслинные стили, не записанные в атрибуте styleюМы можем их только прочитать, менять не можем
const elementStyle=getComputesStyle(element);
console.log(elementStyle.fontSize)//получаем значение свойства fontSize
//также можем получить стили псевдоэлементов
const elementBeforeStyle=getComputedStyle(element,'::before');
console.log(elementBeforeStyle.backGroundColor)
//Чтобы получить результат только числом без ед.изм 10px можно использовать parseInt
const paddingLeft=parseInt(elementStyle.paddingLeft);
//важно не забывать про ед.изм
element.style.marginLeft='20px';

//E каждого DOM-элемента могут быть разные свойства, например у тега <a> есть свойства связаннеы со сылками, а у тега <input> свойства связанные с формами
cosnt link=document.querySelector('.lesson__link')
cosnt value=document.querySelector('.lesson__input')
console.log(link.href)//покажет ссылку
console.log(input.value)//покажет значыение атрибута value
console.dir(link)//Для просмотра всех доступных свойств

//Произвольнеы атрибуты
lessonText.hasAttribute('name')//проверяем наличие атрибута
lessonText.getAttribute('name')//получаем значение атрибута
lessonText.setAttribute('name', 'value'-тут пишем значение которе хотим присвоить)//устонавливаем значение атрибута
lessonText.removeAttribute('name')//удаляем атрибут

//Получаем data атрибут/ Все атрибуты с префикс 'data-' зарезервированы для использования програмистами. Они доступы в свойствах dataset
// <div data-size='1058'><div/>

console.log(lessonText.dataset.size)
lessonText.dataset.size="5810"//изменяем значение

//data-size-value в стиле lowCamaleCase
log(lessonText.dataset.sizeValue)


//ПОЛЕЗНЫЕ СВОЙСТВА

log(link.tagName)//получаем тег элемента
link.hidden=true;//скрыть / показать элемент

```

- $0 сохраняем элемент выделенный в дереве дом в браузере под данной переменной и можем в консоле что-то с ним делать

# Лекция Event=====================

```javascript
<button onclick="console.log('Клик!')"></button>; //вешаем обработчик через html
const button = querqSelecto('.button');
button.onclick = function () {
  console.log('Клик!');
  //отменяет стандартные действия допустим переход пы ссылки
  return false
}; //вешаем обработчик через JS, однако с помощью данного метода нельзя повесить болье двух обработчиков, будет работать только последний
function showConsole() {
  console.log('Клик!');
}
button.addEventListener('click', showConsole); //здесь же работают два обработчика на одно событие
button.addEventListener('click', function () {
  console.log('Клак!');
});

button.removeEventListener('click', showConsole); //убираем обработчик событий
function showConsole() {
  //в данном случае обработчик сработает только один раз и потом сниметься
  console.log('Клик!');
  button.removeEventListener('click', showConsole);
}
// Опции, у боъекта addEventListener есть три параметра
const options = {
  capture: false, //фаза  на которой должен сработать обработчик? используеться при погружении, чтобы сработал обработчик
  once: false, // если true, тогда обработчик будет автоматически удален после выполнения, замена removeEventListener
  passive: false, //если true, то указывает, что обработчик никогда не вызлвет prevenDefault (отменяет действие event.preventDefault)
};
button.addEventListener('click', showConsole, options);
button.addEventListener('click', showConsole, { capture: false });

//Объект события. Когда происходит событие браузер создает объект события, записывает в него детали и передает его в качестве аргумента функции-обработчику
event.type; //тип события
event.target; //получаем объект на котором сработал обработчик (может быть объект которому присвоен обработчик, а может быть его дочерние элементы)
event.currentTarget; //получаем только тот объект котрому назначен обработчик
event.clientX; //положение курсора по оси Х
event.clientY; //положение курсора по оси Y
event.target.closest('.button') //тут мы проверяем что обработчик сработал на элементе с классом button
event.which//gjkexftv как кнопка мыши нажата 1-основная (левая), 2-колесико,3- правая
console.log(event); //можем узнать все детали события

//Всплытие
//Когда на элементе происходит событие обработчик сначала срабатывают на нем, потом на его родители затем выши и т.д., вверх по цепочке предков

event.stopPropagation();//отмена всплытия, когда уу на срабатывает обработчик события на вложенном элемент, данный метод отменяет всплытия на других элементах и сработает обработчик только на нем.Остонавливать всплытие нужно остарожно и точно понимаю что делаешь.

//Чтобы что-то всплыло оно сначало должно погрузиться, можно добавит аргумент capture: true и тогда сначало сработает данный обработчик а потом будет присходить всплытие и будут сробатывать обработчки по принципу всплытия.

//Делегирования события-событяи позволяет вешать не множество обработчиков а один к примеру:
const lesson document.querySelector('.lesson');
function showconsole(){
	console.log('Ура!')
}
addEventListener("click", (event)=>{if(event.target.closest('.button')){//event.target.closest('.button') тут мы проверяем что обработчик сработал на элементе с классом button
	showConsole()
}})//в данном случае обработчик будет срабатывать на всех элементах с классом button

//Основы событий мыши
"click"
"dbclick"//двойной клик
"mouseover"//курсор над элементом, всплывает
"mouseout"//курсор уходит с элемента, всплывает(если есть дочерние элементы то при переходе на него и с него будут срабатывать)
"mouseenter"//курсор над элементом, не всплывает(если есть дочерние элементы то при переходе на него и с него не будут срабатывать)
"mouseleave"//курсор уходит с элемента, не всплывает

//Основные события клавиатуры
"keydown"
"keyup"
event.code//выводит KeyG тут регитср не меняеться , раскладка тоже
event.key//выводит (g) (G) меняеться регистр, есть зависимость от языка

"scroll"
```

# Лекция 111 NODE=======================

- Node-это среда для запуска JS кода
- С помощью node "Наименование файла" -запускаем скрипт js в консоли, запускаем код
- node v узнаем версии node
- Если вывести данную функцию в консоль то можно сократить вывод пути в
  терминале :
  ```javascript
  function global:prompt {
  $p = Split-Path -leaf -path (Get-Location)
    "$p> "
  }
  ```
- npm init преобразует фаил в пакет npm нужно для подгрузки библиотек
  npm init --yes (-y) (если устраивают значения по умолчанию).
- подключаем библиотеку fyle system:

```javascript
const fs = require('fs');
```

- подключаем методы работы с файлами из библиотеки 'fs'. используем ${\_\_dirname} чтобы не было проблем с относительными путями.
- \_\_filename-выводит полный путь до файла ввключая его название.

- Методы fs :
  ```javascript
  fs.readFileSync(`${__dirname}/cats.txt`, 'utf-8'); //В данном случаи используем метод прочитать
  fs.writeFileSync('./numbers.txt', text); //перезаписывает новые данные, если фаил не существует то создает его
  fs.appendFileSync('./numbers.txt', text); //добавляем информацию в конец списка.
  ```
- process.argv такой объект который позволяет из командной строки взять данные которые передает пользователь.
- таким образом подключаем сторонние библиотеки:

```javascript
const parsePhoneNumber = require('libphonenumber-js');
```

- module.exports = {} экспортируем функции создавая объект.
- импортируем js фаил и деструктуризируем его:

```javascript
const { printNumbers, addNumber } = require('./actions');
Массивы:
// Обмен значениями переменных
let a = 1, b = 2;
[a, b] = [b, a];
// теперь a = 2, b = 1

// Пропуск элементов
const [first, , third] = [1, 2, 3];
// first = 1, third = 3

// Оставшиеся элементы (rest)
const [head, ...tail] = [1, 2, 3, 4, 5];
// head = 1, tail = [2, 3, 4, 5]

Объекты:
// Переименование переменных при деструктуризации
const { x: a, y: b } = { x: 1, y: 2 };
// теперь a = 1, b = 2

// Значения по умолчанию
const { x = 0, y = 0, z = 0 } = { x: 1, y: 2 };
// x = 1, y = 2, z = 0

// Деструктуризация в параметрах функции
function printCoordinates({ x, y }) {
  console.log(`x: ${x}, y: ${y}`);
}
printCoordinates({ x: 1, y: 2 });
// вывод: x: 1, y: 2
```

- npm -это "программа" репазиторий где лежат другие библиотеки.
- npx -программа которая скачивает пакет в кеш и сразу его запускает "npx cat-me".
- npx eslint --init установка eslint не глобально.
- npm i (или install) cat-me --D чтобы поставить в devDependencies.
- npm un cat-me чтобы удалить.

# Лекция 112 Array=======================

- npm i (или install) cat-me --D чтобы поставить в devDependencies
- npm un cat-me чтобы удалить
- настройки форматирования чтобы при сохранении в файле сразу добавлись
  одинарные ковычки:

```javascript
    "prettier": {
   "printWidth": 80,
   "singleQuote": true,
   "trailingComma": "es5",
   "tabWidth": 2,
   "semi": true}
```

- ctr+shift+p Fixx => Eslint Fixx all исправляем возможнеы ошибки автоматически.
- по правилом хорошего тона мы всегда пишем const и используем let только тогда когда пременную нам нужно поменять, делает код более удобочитаемым и меньше подтвержденным ошибкам.
- цикл переберает массив с индексом, break останавливает итерацию после выполнени условия:

```javascript
for(let i-0,i<arr.lenght,i+=1)
```

- цикл for(const "новый массив" of arr)-переберает без индексов.
- задачи связанные с циклами лучше решать методами, а уже потом циклами.
- код должен хорошо читаться.
- когда мы записваем callback то лучше записываеть его как стрелочную функцию.
- метод forEach лучше использовать тогда когда есть уже функция к примеру:

```javascript
function printFruit(value){console.log(`Фрукт: ${value}`)}
forEach(printFruit).
```

- Массив -это упорядочная коллекция элементов, где элементы могут быть любым типом данных.
- repl если мы терминалае введем node то мы попадем repl "repl" расшифровывается как "Read-Eval-Print Loop", что означает интерактивную среду разработки, которая читает вводимые команды, выполняет их, выводит результаты и ждет следующую команду от пользователя. командная строка которая помогает исполнять JS выражения.
- не примитивные типы данных при присвоение (объекты,массивы ) присваиваються как ссылки и при изменение второй переменной меняеться и первая.
- библиотека lodash когда нужно строгое копирование.
- глубокое копирование, не примитивные типы данных копируються не как ссылки.Лучше использовать библиотеку loodash а не JSON так как он очень медленный:

```javascript
const cats2 = JSON.parse(JSON.stringify(cats));
```

- cats2.push({ name: 'Sima', age: 3 });-неглубокое копирование(поврехностное-копируеться лишь ссылка на объект или массив).
- spread оператор const cats2 = [...cats, { name: 'Li', age: 8 }]; неглубокое копирование(поврехностное), spread создаем новый массив и разьмещаем туда старый как бы распределяем его
  и также можем добавить новые элементы массива.
- Quokka -разрещение для VScoda, где результат появляеться сразу в JS файле.
- Если в методе нам не нужен какой-то аргумент мы вместо него пишем нижнее подчеркивание .map(\_, index)

### МУТИРУЮЩИЕ методы массивов: push, pop, unshift,shift, splice, reverse,sort.

- .unshift() -добавляет в начало. Возвращает новую длину массива.Мутирует массив.
- .shift() -удаляет первый элемент и возвращает его.Мутирует массив.
- .push() -добавляет в конец массива. Возвращает новую длину массива.Мутирует массив.
- .pop()-удаляет последний элемент и возвращает его.Мутирует массив.
- .splice()- возвращает массив удаленных элементов. Мутирует. Вставляет элементы при необходиости.
- .splice(1,2,'day') второе значение '2' -это количество удаляемых элементов.
- .reverse()-переворачивает массив мутирует его, создает такой же массив, не нужно создавать переменную под него.
- .sort()-отсортировывает элементы массива по умолчанию как cтроки, но правильно задавать callback функцию cats.sort((a,b)=>{a.age-b.age } ) -в основном данный метод используеться для сортировки числового массива.
- .includes(сюда передаю имя массива непосредственно) -нахожу значение массива.
- .indexOF (сюда передаю имя массива непосредственно) -нахожу индекс массива.
- .fill()-заполняет массив повторяющимеся значениями.

### НЕМУТИРУЮЩИЕ методы массивов:slice,map,filter, concat,reduce, split,join, forEach.

- метод масива forEach()-переберает массив с помощью callback функции, лучше использовать обычные циклы так как они занимают меньше места. Метод forEach лучше применять когда callback функция уже существует.
- .split() - разбивает строку на массив. Аргументом принимаеться разделитель(" ").
- .join() - склеивает элементы массива в строку. Аргументом принимаеться что будет разделять элементы в строке(" ").
- .slice() - возвращает новый массив или кусок массива, если укажим в аргумента диапазон индексов (1) или (1,2) 2 не вкл.
- concat()- соеденяет массивы и в конце можно добавить еще дополнительный элемент. .concat(array,array2, "Петя").
- find()-находит первый элемент(вывел первый и дальше не идет) в массиве соответствующий условию callback и выводит его,если его нет выводит undefind
- findIndex()-находит первый элемент(вывел первый и дальше не идет) в массиве соответствующий условию callback и выводит индекс этого элемента,если его нет выводит undefind
- filter()-возвращает новый массив , элементы которого удовлетворяют условию в callback функции.нужен для того чтобы на основе исходного массива создать какой-то новый ,значения которого будут те значения которые возвращает callback функция. при каждой итерации. filter используется для фильтрации элементов массива с помощью булевых значений true, false в новый массив выводиться true. filter.((element,index,initialArray)=>{console.log({element,index,initialArra});return typeof element==='number' })
- map()-возвращает новый массив. Запускает для каждого элемента callback функцию, которая может как-то изменять текущий элемент.map - используеться для преобразования элементов массива.
- every()-вызывает callback для каждого элемента массива. Если callback хотя бы одного элемента вернет false(проверяет лениво до первого false),то весь метод вернет false.
- some()-вызывает callback для каждого элемента массива. Если callback хотя бы одного элемента вернет true (проверяет лениво до первого true),то весь метод вернет true.
- reduce()-сворачивает массив в результирующее значение .reduce(acc,element,index,array) (где acc-переменная, хранящая промежуточные значения результата) используеться для подсчета суммы значений массива цифр (лучше использовать только так)
- в массивах можно записывать цепочечным синтексисом, когда методы идут друг за другом через точку

```javascript
allCats.filter.map.reduce;
```

# Лекция 113 DEBUGGING-RECURSION=======================

- Отладка- полезный функционал для просмотра как у тебя ведет себя кода во время ошибки. Заходим в меню отладки ставим метку и запускаем отладку. Можем двигаться поэтапно.
- Рекурентное соотношение называеться функция которая выражаеться через такую же функцию но от другого аргумента.
- Последовательность фибоначи-это последовательность чисел каждый челен которой равен сумме двух предыдущих.
- Задачи на рекурсию решаеються составлением рекурентного соотношения. Рекурентное соотношение, должно быть хотя бы одно искомое значение иначе рекурсия будет уходить в бесконечность. В рекурентном соотношение где функция вызывает себя назваеться рекурентным случаем, где нет базовым случаем.
- Нахождение челена последовательности фибоначи по порядковому номеру с помощью рекурсии -const fib=(n)=>n>=2?fib(n-1)+fib(n-2):n;.
- Факториал числа это произведение чисел по это число наичная с одного -const fac=(n)=>n>0?fac(n-1)\*n:1;
- Алгоритм- это последовательность действий которая приводит к результату.
- O()-сложность алгоритма сколько шагов нам придеться сделать в худшем случаи.
- O(log2(n))=O(lgn)- сложность бинарного поиска, высчитываем максимальное количество итерации при бинарном поиске. (a^x=b loga b=x)
- Пузырьковый поиск каждый элемент сравниваетьс с последующим и так прооисходит до того когда самый большой не всплывет на верх как пузырек. Имеет сложность O(n\*n)-квадратичная сложность
- Квадратичная сложность до 10 000 элементов норм после уже не очень.
- Вложенные циклы это n в квадрате-тоесть квадратичная сложность , рекурсия это логорифмическая ложность O(n\*logn )
- Книжка "алгоритмы построение и анализ" Кормен Томаз

# Лекция 114 Strings, RegExp=======================

- \n -перенос строки.
- \t -tab.
- `- бэктики( шаблонные строки)-нужны для создания шаблона куда можно передавать JS код. Для переноса строк через enter.
- строка это массив стостоящий из символов. Строка это примитив ее не нельзя изменить как массив.
- .indexOF(' ', тут вводишь индекс с какого хочешь начать или не вводишь)-ищет первое совпадение заданых символов
  и выводи его начальный индекс. -1 -совпадений нет.
- .lastIndexOF - поиск с конца последовательности символов.
- .includes-определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.
- .slice()-возвращает все символы от стартового индекса.
- replace('такой'. 'не') - возвращает новую строку с заменой первого совпадения на шаблоне.
- ALT +"стрелка вниз"+shift копирует строку.
- ALT +"стрелка вниз" перемещает строку.
- ALT +и наводишь курсор -появляеться мульти курсор и можно сразу исправлять в разных местах.
- F2 -исправляет данные сразу во всех строках.
- const [left,right] = str.split("@"); -деструкторизация в работе с массивом (берем его 0 и 1 элемент их всего два разделленные по @)
- .charCodeAt(0) - Метод используется для получения кода символа в указанной позиции строки. В данном случае, позиция указана как 0, то есть метод вернет код первого символа строки.

- Регулярные выражения (Regular expressions, или просто regex) - это синтаксический формат, позволяющий искать и сопоставлять текстовые строки с определенным шаблоном. Они используются для поиска и замены текста в текстовых редакторах, языках программирования и других средствах обработки текста. Регулярные выражения состоят из серии символов, которые определяют шаблон поиска. Например, для поиска всех слов, начинающихся с буквы "a", в тексте можно использовать регулярное выражение /a\w*/gi, где \w представляет любую букву или цифру, а * означает "любое количество раз". В JavaScript и других языках программирования регулярные выражения создаются с помощью объекта RegExp или литералов (например, /a\w\*/gi). Любой метод регулярного выражения проверяет только первое вхождение регулярного выражения.
- console.log(/[][][]/.test(наименования перменной котрую мы проверяем на наличия шаблона))-метод проверки есть ли в переменной соответствующий шаблон с выводом булевого значения;

```javascript
 []-диапазон, в квадратные скобки записываем диапазон символов которе будут искаться в переменной в одном элементе
  [0-9]-любая цифра
  [^0-9]-все кроме цифр

- Символьные классы :
  \d-любая цифра(0-9),
  \D-все кроме цифр,
  \w -a-z, A-Z, 0-9, _ ,
  [a-z0-9]-указываем любая буква в нижнем регистре и любая цифра
  \W-все кроме (a-z, A-Z, 0-9, _ ),
  \s - все пробельные символы ( \n\t),
  \S -все кроме пробелmys[ символов]
  . -любой символ
```

- Квантификаторы {4}-количество повторений символов, относиться именно к последнему символу после которого он написан (чтобы он считывал все символы как один нужно поставить их в скобки(ab1){2})

  ```javascript
  console.log(/\d{4}/.test(phone)); // ровно 4
  console.log(/\d{2,4}/.test(phone)); // от 2 до 4
  console.log(/\d{2,}/.test(phone)); // от 2 до бесконечности
  console.log(/\d{0,1}/.test(phone)); // от 0 до 1
  console.log(/\d?/.test(phone)); // от 0 до 1, {0,1} -этот знак означает либо этот символ есть либо его нет
  console.log(/\d\*/.test(phone)); // от 0 до бесконечности, {0,}-этот знак означает либо этого символа нет либо его может быть любое количество
  console.log(/\d+/.test(phone)); // от 1 до бесконечности, {1,}.-либо один либо много
  ```

- () если мы хотим чтобы квантификатор действоавл на несколько символов то их нужно заключить в скобки

- Якоря ^-начало, $-конец строки

```javascript
console.log(/^\w+@\w+\.[A-z]+$/.test(emailBad));
```

- \b-маркер граница слова, значит что слева и справа должно быть все кроме \w символьного класса (цифры,буквы,\_) и тогда происходит вхождение.
- Флаг g (global) - дает возможность при использования в методе регулярного выражения проверять все вхождения регулярного выражения.
- /i - делает регулярное выражение не чуствительным к регистру, хавает все.
- /m Этот флаг означает, что регулярное выражение должно считать строку многострочной, что влияет на поведение метасимволов "^" и "$".
- Пойманная группа '$&'-прописываем равняеться вхождению регулярного выражения мы ее выводим и можем обернуть допустим в скобки

```javascript
{const text ="hello world!!!  mail1@mail.ru okey  some text  alisher@mail.ru xxx"
console.log(text.replace(/\w+@\w+\.[A-z]+/g,'$&'))}.
```

- Так же если мы элементы вхождения разделим на части выделяя их скобками, то мы можем выделять группы $1, $2
  console.log(text.replace(/(\w+)@(\w+\.[A-z]+)/g, "$2@$1")).
- в replace в заменяемый аргумент можно вызывать callback функцию, где параметр будет найденная подстрока к которой
  мы можем применить новые значения функции.console.log(text.replace(/(\w+)(@\w+\.[A-z]+)/g,(match, left, right) => left.toUpperCase() + right))

- \1 можно вставлять в регулярное выражение если при вхождении нам нужно чтобы какой то результат тоже выводил такую же первую групппу (пример тег).
- (?) с помощью знака вопроса мы можем сделать регулярное выражение не жадным(чтобы ),чтобы оно при вхождении не все вставляло а только нужное.
- exec() в JavaScript используется для поиска соответствий между регулярным выражением и строкой. Когда метод вызывается на регулярном выражении, он возвращает массив со всеми найденными соответствиями. Если совпадений нет, то возвращается null. Данный метод обычно используется вместе с регулярными выражениями (RegExp), чтобы искать и извлекать определенные значения из строк и выполнять другие операции.
  -.match() выводим все вхождения которые нашлись console.log(tag.match(/<[a-z]+>.\*?<\/[a-z]+>/g)).Это массив с вхождениями, индексом, строкой;

# Лекция 115 GIT=======================

npm init -y-создаем пакеджь джейсон
npx eslint --init
npm i express -это большой пакет ,фреймворк, позваляет писать быстро серверные приложения на JS
npm i sequelize sequelize-cli pg pg-hstore -для подключения postgress СУБД
touch index.js - создание файла через консоль
npx sequelize init - инициализация сикволайза

- 1 git init создание репозитория в текущей директории(как я понял это создание локального репозитория).
- 2 npx create-gitignore node добавляем фаил gitignore-список файлов папок игнорируемые в GIT.
- git status -отображает текущее состояние локального репозитория.
- 3 git add -A добавляет все файлы в отслеживание.
- 4 git commit -m "commit text" -(текст сообщения) коммит с сообщением - фиксация изменений в репозитории.
- 5 git remote add origin <url> - привязка локального репозитория к удаленному, где url адрес репозитория
- 6 git push <origin main> - используется для отправки изменений, внесенных в локальный репозиторий, на удаленный репозиторий в Git.
- Потом тим лид мерджет ,чтобы соеденить ветки.
- git fetch origin -подтягиваем все изменения с удаленного репозитория в локальный.
- 7 git pull origin master -Команда "git pull" используется для получения последних изменений из удаленного репозитория и объединения их с т екущей локальной веткой в Git.
- 8 git checkout -b <name branch> - создание и переключение в новую ветку.
- 9 git clone <url> -копирования проекта из удаленного репозитория.
- 10 git branch --show-current -узнаю на какой ветке я нахожусь.

- git remote get-url origin-посмотреть к какому репозиторию привязаны.
- git remote -v проверяем добавился ли репозиторий.
- git remote add origin <url> - привязка локального репозитория к удаленному, где url адрес репозитория
- git reset HEAD~1 - удаляет последний коммит ЛОКАЛЬНО и возвращает все изменения в рабочую область (число указывает количество коммитов которые нужно откатить).
- git revert HEAD - откатывает последний коммит (создавая новый противоположный коммит) и возвращает все изменения в рабочую область.
- git cherry-pick <Commit1> <Commit2> <...> - rebase оперделнные коммиты в ветку в которой находимся.
- git rebase -i HEAD~4 - переключение на 4 коммит назад и можем переставить местами коммиты и убрать не нужные.
- git commit --amend -
- git tag V1 C1 - создание тега V1 на коммите с хешом C1.
- git describe <наименование ветки и коммита откуда ничнаеться отсчет> - показывает, как далеко текущее состояние от ближайшего тега (выдает v1-2-gC6- тег(первый встречающийся)-кол.коммитов до него-g последни хеш коммита).
- git add README.md добавляем фаил README.me.
- git branch -список имеющихся у вас веток.
- git branch <name branch> - создает локальную ветку.
- git branch -d <name branch> - удаляет локальную ветку, если ее содержимое влито в основную. Если пользователь флаг -D (большая буква), ветка удаляеться принудительно.
- git checkout HEAD^ - переключение на предыдущую коммит.
- git checkout HEAD~4 - переключение на 4 коммит назад.
- git branch -f <main> HEAD~3 -перемещаем ветку main на 3 коммит назад.
- git branch -M <main> - переименовывает локальную ветку.
- git checkout <name branch> - переключение на заданную ветку .
- git checkout -b <name branch> - создание и переключение в новую ветку.
- Библиотеки лучше чтобы ставил тимлид(один человек)
- git checkout <name branch> , git merge <name branch> - комиты из мастера mergim в свою ветку, создаться комит слияния в нашей ветке (все изменения из мастера добавляються в нашу ветку) история commitov сохраняеться используеться для работы в команде над одной веткой
- git checkout <name branch> , git rebase <name branch> - комиты из мастера mergim в свою ветку, только в данном случие истоия комитов в нашей ветке слетает и наши комиты ставяться заново перед веткйо main как будто мы только то от нее отпачкрвались и начали комитить.
- git clone --branch master --single-branch https://github.com/AidarSm/KamaTodo.git -клонирование конкртеной ветки

# Лекция 121 Objects, this, prototypes =======================

```javascript
const field = 'paws count';

const ray = {
  name: 'Ray',
  age: 4,
  [field]: '4',
  'teeth count': '24',
  10: { a: ['value'] },
};
```

- Объект это набор пар ключ:значение(упорядоченый список ).
- Object.keys(название переменной которой присвоен объект) -выводим все ключи объекта в массив.Ключами могут быть строки(name)без ковычек или с ковычками валидной строкой ('paws-count') (в них мы можем ставить пробелы тире и т.д.), числа (10). В данном методе числа сортируются в порядке возрастания( даже если их сразу завести строкой) и раньше строк и выводяться в массив как строка, строки остаються в том порядке в котором мы их завели.Если мы хотим в качесве ключа вставить переменную то ее мы имя мы должны поместить в [...].
- Object.values(ray)-Вывести масив всех значения.
- Object.entries(ray)- Вывести двойной массив(массив пар).
- Object.assign(ray,{favoriteToy:'pig',favoriteFood:'cucumber'}) -вставляем новые пары , используется для объединения свойств из разных объектов в один целевой объект их замены если такой ключ уже есть или создания новой пары если ее нет.
- Создаем новый объект roy где раскладываем старый объект ray и добавляем новое поле name:'' которое заменит поле в объекте ray(последний элемент в объекте заменяет предыдущий,если такой был)

```javascript
const roy={...ray, name:'Roy' , gav:'гав'}
  *for(const key in ray){
  console.log(key);//выведим ключи
  console.log(ray[key]);//выведим значение
  }//перебираем ключи циклом.
  *console.log('name' in ray)//проверяем есть ли такой ключ в объекте rey выводим булевое значение.
  *console.log(ray.hasOwnProperty('name'))//проверяем есть ли такой ключ в объекте rey выводим булевое значение.
```

- Когда объект используеться как таблица лучше использовать класс Map. Он гораздо быстрее работате, если писать на typeScripte то это лучше типизируеться
- Тут можно задавать ключем объект:

```javascript
const vanya = {
  name: 'Vanya',
};
const groupmap = new Map([
  ['Ваня', 4],
  [vanya, 4],
]);
console.log(groupMap.get(vanya));
4;
```

- Обращение к полям

```javascript
console.log(ray.name);
console.log(ray['teeth count']);
console.log(ray[field]);//название переменной
console.log(ray[10].a[0])//имя ключа, имя ключа[индекс] (10:{a:['value']}.-получаем 'value').

- delete ray[10]//Удалить поле, 10-это ключ.
- ray.breed = 'siba inu';//вставляем новое поле ray-название объекта, breed-ключ, siba inu- значение.
  ray.breed = 'siba inu';
  ray[field]=5;
  ray['teeth count']=25;

```

- Значением может быть массив в котором есть объект, функция 10:{a:['value']}.
- ray.name=ray['name'] -одна и таже запись.обращение к значению поля ray-название объекта, name-ключ. Обращение через точку возможно только если ключ начинаеться со строчного символа.

- ООП Объектно ориентированное программирование-это подход в програмирование где все сущности предстовляються некоторыми объектами. Человек видит внешний мир как объекты:стена, ноутбук, стол с некоторыми свойствами присуще им. Не очень естественные для нас алгоритмы програмирование превращаем в абсолютно естественные и удобны для нас объекты, собственно как мы и мыслим.

- Прототип в JavaScript — это механизм, который позволяет объектам наследовать свойства и методы от других объектов. Прототип объекта — это объект, от которого текущий объект наследует свойства и методы. Когда вы пытаетесь получить доступ к свойству объекта, JavaScript сначала проверяет, есть ли это свойство у самого объекта. Если нет, то поиск продолжается по цепочке прототипов, пока не будет найдено соответствующее свойство или не достигнет конца цепочки
- Метод-это функция которая принадлежит некоторому объекту, в значение объекта мы вызываем функцию.
- this.name-this используеться для передачи контекста. Создаем некую шаблонную функцию которую можно будет вставлять в объекты как метод и она будет работать,где this будет считаться сам объект. This работает только тогда когда есть контекст, и поэтому если он теряеться то можно использовать метод rexGetInfo.call(ray)-искуственно передаем контекст.
- call и apply используеються для передачи контекста функциям: принимают объект контекст которого нужно взять и аргументы функции
  call(<obj>,<аргументы функции>,<аргументы функции>...) -принимает сколько угодно арг.по одному
  apply(<obj>,<[массив аргументjs функции]>) -принимает массив значений, это удобно когда мы не знаем заранее сколько аргументов мы передадим функции
- bind тоже привязывает контекст но не вызвает функцию сразу , он создает новую функцию с контекстом поэтому ее нужно присвоить переменной чтобы использовать ее. const newMyFunction=myFunction.bind(<obj>,<аргументы функции>,<аргументы функции>...) вызываем функцию newMyFunction()

- SOLID — это акроним, представляющий пять основных принципов проектирования объектно-ориентированного программирования и разработки программного обеспечения. Эти принципы были введены Робертом Мартином в его книге "Clean Code". SOLID является аббревиатурой от следующих пяти принципов:

S - Принцип единственной ответственности (Single Responsibility Principle, SRP): Каждый класс или модуль в программе должен иметь одну и только одну причину для изменения. Это означает, что класс должен выполнять только одну задачу.
O - Принцип открытости/закрытости (Open/Closed Principle, OCP): Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для изменения. Это означает, что можно легко добавлять новые функции без изменения существующего кода.
L - Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP): Функции, которые используют базовые типы, должны иметь возможность использовать объекты производных типов без знания об этом. Это означает, что объекты производного класса должны быть заменяемыми на объекты базового класса без нарушения корректности программы. Через реакт-базовый компонент имеет некий интрефейс, создавая подтип данного компонента м ы наследуем интерфейс баз.комп. и дополняем его по необходимости. Внедрение принципа позволяет сделать использование подтипов предсказуемыми и заменять базовые компоненты на подтипы.
I - Принцип разделения интерфейса (Interface Segregation Principle, ISP): Клиенты не должны зависеть от интерфейсов, которые они не используют. Это означает, что большие интерфейсы следует разбивать на меньшие и более конкретные, чтобы клиенты могли использовать только те интерфейсы, которые им нужны.
D - Принцип инверсии зависимостей (Dependency Inversion Principle, DIP): Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Это означает, что зависимости должны быть направлены на абстракции, а не на конкретные реализации.
SOLID является ключевым принципом в объектно-ориентированном программировании и разработке программного обеспечения, направленным на создание более чистого, модульного и легко поддерживаемого кода. Соблюдение этих принципов помогает разработчикам создавать более надежные, масштабируемые и легко поддерживаемые системы.

```javascript
function getInfo() {
  return `${this.name}, ${this.age} years`;
}
const rex = {
  name: 'Rex',
  age: 4,
  getInfo,
};
console.log(rex.getInfo());
```

- Классы и экземпляры-для удобства работы со схожими объектами придумали классы (чтобы сократить код). Классы пишуться с большой буквы, экземпляры с маленькой. Классы это не кое описание экземпляров ,когда экземпляры это существующие объекты. В классах мы прописываем возможные ключи объекта, а в экземплярах мы указываем уже их свойства.

- Создаем функцию конструктор(класс) и присваеваем ей метод(через прототип).В JavaScript функция-конструктор (constructor function) — это обычная функция, которая предназначена для создания и инициализации новых объектов.Она используется с оператором new для создания экземпляра объекта с определенной структурой и свойствами. Это класс Animal над классом Dog.

```javascript
function Animal(name, age) {
  this.name = name;
  this.age = age;
}
Animal.prototype.getInfo = function () {
  return `${this.name}, ${this.age} years`;
};
```

- Метод неопределен-это делает класс абстрактным, его нет смысла инстанцировать.Инстанцировать- значит создавать экземпляр на его основе,наверное это делаеться чтобы на его основе не использовали данный метод

```javascript
Animal.prototype.makeSound = function () {
  throw new Error('not implemented');
};
```

- Функция конструктор(класс).В функции конструктор мы создаем объект с помощью this и создаем там ключи name и age и присваеваем им значение с помощью переменных (name,age).
- Вызываем функцию конструктор, в нее передаеться пустой объект
  function Dog(name, age) {
- Теперь созданный пустой объект передаеться в качестве this в функцию конструктор Animal и ему назанчаються все свойства из Animal name, age
  Animal.call(this, name, age);
  this.info = `${name}, ${age}`;
- this.getInfo=()=>{}; -можно метод присвоить вот так,а можно с помощью прототипа.В общем, методы, добавленные через прототип, являются предпочтительным способом добавления методов к объектам, созданным с помощью функций-конструкторов, поскольку это позволяет избежать дублирования методов и экономить память

  Связываем прототипы.Делаем цепочку прототипов у прототипа Dog прототипом буде Animal. Создаем связь между двумя классами.

  ```javascript
  Object.setPrototypeOf(Dog.prototype, Animal.prototype);
  ```

  - Создаем прототип объекта(с помощью него присваемаем объекту методы )- методы кладем в прототип

```javascript
Dog.prototype.makeSound = function () {
  return 'WOF WOF';
};
Dog.prototype.digGround = function () {
  return 'Я докапаюсь до ядра земли';
};
```

- Получаеться когда мы создаем собачку new Dog сначала вызваетcя функция конструктор.
- Создаем экземпляры с помощью класса Dog через new.

```javascript
const rex = new Dog('Rex', 10);
const sharik = new Dog('Sharik', 1);
// объекта шарик и рекс не равны, но их прототипы равны
console.log(rex === sharik);
false;
// console.log(rex.**proto** === sharik.**proto**);true

// Проверяем являеться ли объект экземпляром класса Dog
console.log(rex instanceof Dog);
true;

// Выводим метод
console.log(rex.getInfo());
```

- Можем посмотреть что находиться в прототипе с помощью метода Object.getPrototypeOf(rex) console.log(Object.getPrototypeOf(rex));
- Можем увидеть что у прототипа rex есть другой прототип Animal console.log(Object.getPrototypeOf(Object.getPrototypeOf(rex)));
- Проверяем являеться ли объект экземпляром класса Dog console.log(rex instanceof Dog);true
- Можем посмотреть что находиться в прототипе с помощью метода

```javascript
Object.getPrototypeOf(rex) console.log(Object.getPrototypeOf(rex)); Dog{getInfo:}
```

- console.log('getInfo' in rex); true-узнаем есть ли данный метод в объекте rex.
- console.log(rex.hasOwnProperty('getInfo'))false-проверяет если ли данный метод именно у объекта rex, а не у его прототипа.

# Лекция 122 Classes =======================

- Синтактсис класса:

```javascript
//Создаем класс, в него записываем функцию конструктор и его методы
class Animal {
constructor(name, age) {
this.name = name;
this.age = age;
}
sayHi() {
console.log(`Привет, я ${this.name}`);
}
}
//Создаем "под класс" Fox и создаем между Animal и Fox наследовательность "связь" с помощью extends и прописываем в функцию конструктор super(здесь аргументы из Animal)

const Animal = require('./Animal');

class Fox extends Animal {
constructor(name, age, color) {
super(name, age);
this.color = color;
}
}

Module.exports = Fox;-экспортируем класс
```

- Если мы принимаем от пользователя уже готовый объект а не сами его заполняем

```javascript
// 1 вариант ставим фигурные скобки в аргумeнтах, диструктуризация. Нюанс такой что когда мы принимаем объект, то в функции конструктор мы можем заполнять аргументы не соблюдая
// последовательность, и данные подгузяться верно.Но если передавать как параметры функции, то нужн особлюдать последовательность. Также такую же логику нужно соблюдать
// передовая переменные через super, но там уже нельзя передать информацию через объект.
class Fox extends Animal {
  constructor({ name, age, color = 'white' }) {
    super(name, age);
    this.color = typeof color === 'string' ? color : 'white'; // создали проверку на ввод строки
  }
}

// 2 вариант передаем перменную к которой присвоен объект
class Fox extends Animal {
  constructor(peremennay) {
    super(peremennay.name, peremennay.age);
    this.peremennay.color = color;
  }
}
```

- Статические методы класса-используються для создания методов которые можно использовать только в классах, но нельзя использовать в экземплярах , например: Fox.info. В других экземплярах он будет неопределен. Статические методы правильно прописывать до конструктора. Также можно создавать в классах статические переменные
  которые будут видны только в классах, но не будут видны в экземплярах.

```javascript
class Fox extends Animal {
  static info() {
    console.log('я еще животное');
  }
  constructor({ name, age, color }) {
    super(name, age);
    this.color = typeof color === 'string' ? color : 'white';
    this.color = color || 'white';
  }
}
```

- Геттеры и сеттеры, приватные поля-c помощью знака решетки '#' создаем приватное поле(#password=1234) которое будет не видно(видно только в самом классе, если мы допустим там пишем метод). Но с помощью метода get 'название метода' (){return this.#password} мы можем вытащить это приватное поле, а с помощью метода set изменить, но лучше использовать проверки при этом методе.

```javascript
set 'навзание метода'(value){if(value>=0){return this.#password=value; }}
// Приватный метод
#privateMethod(){
return (this.number*this.number)
}
// Используем '_' перед именем, чтобы показать, что это "защищенное" свойство

```

# Лекция Asynchrony, eventloop 123 =============

- API(aplications program interfeic) -набор функции в который мы можем что-то передовать и получать некий результат.
- команда time node index.js-показывает за какой время выполняеться код
- Асинхронность -возможность несколько задачь делать одновременно.
  -Event loop-решает проблему асинхронности

- Event Loop в Node.js- цикл событий JavaScriptа, где код запускаеться и помещаеться в некую очередь, после запускаеться движек javascripta V8(он однопоточный исполняет только одну задачу)видет что сидит в очереди код и выполняет его поэтапно, и когда в коде появляються (fetch,fs -асинхронные операции) направляеться агенту libUV(это программаа, многопоточный исполняет несколько задач),который в свою очередь выполняет асинхронные операции(fetch(запрос к серверу), fs(прочитка документов ),database (общаеться с базой данных), exec(запускает программы на компьюетере)), и когда приходит ответ от сервера он выполняет callback и он помещает этот callback с результатом в очередь и движек V8 вновь запускаеться и выполняет код в callbacke и когда все запросы агента выполнились и очередь пустая программа выполнилась.

- синхронный коды выполняеться в стеки вызовов call stack движком браузера у Chroma это V8, у Firefox spiderMonkey, у safari JSCore, у MicrosoftEdge Chakra

Event Loop в бразере-это посути две очереди макро и микро очереди задач, где сначало выполняються микро задачи потом выполняеться одна макро задача и если она создают микрозадачи то выполняються они, а уже потом следующая макро задача.

- микротаски-в очердь микротасок поподают promise, специальнеы функции queveMicrotask(специальная функция которая помещает func в очередь микрозадач.), mutationObserver, в первую очередь выполняються они а после 1 макротаска.
- макротаски- в очередь макротасок попадают таймеры (setTimeout, setinterval), события(клик, загрузка изображения и т.д.), Браузерные нюансы(рендер, I/O, и т.д.)

- Рендер браузера:
  Строиться ДОМ дерево > строиться СSS object module дерево > по итогу получаем дерево рендера Render Tree затем проходим 4 стадии :
  style calculation(калькуляция стилей-применения селекторов к элементам ) > Layout (макет -по размерам и позициям раставляет элементы (грубо говоря чертеж макет)) > Paint (рисует из чертежа пиксели) > Compositing (работа со слоями-наслоение друг друга)

- console.error(err)-выводит неприятным красным цветом
- Чтобы сделать асинхроннный код синхронным приходиться использовать callbackи и за того что их очень много получаеться callback hell.
- В асинхроннеы API связанный с библиотекой fs ,первым делом передаються параметры а потом callback.
- Таймеры.Для того чтобы запустить таймер в JS нужно вызвать данную функцию, первым передаеться callback, а вторым параметр задержки в милисекундах.
- Данный метод один раз отработал и умер.

```javascript
console.time();//для фиксация времения таймаута
setTimeout(() => {
console.timeEnd();//для фиксация времения таймаута
console.log('Привет! ');
}, 1000);
Данный метод не совсем точный.
setTimeout(() => console.log(1), 0);
setTimeout(() => console.log(2), 0);
setTimeout(() => console.log(3), 0);
console.log(4);
// Что первый выйдет в лог? Первыйм выйдет 4, так как данный код синхронный и сначала движек V8 выполнит его,а уже потом передаст callbackи
// в libUV и уже потом выполняться они
// Так как операция асинхронные они могут перепутаться и выйти не друг за другом, но чаше всего выполняються последовательно.
```

- счетчик через setInterval вызываеться много раз

```javascript
let count = 4;
const interval = setInterval(() => {
  if (count === 0) {
    console.log('boom!');
    // остановить работу интервала
    clearInterval(interval);
  } else {
    console.log(count);
    count -= 1;
  }
}, 1000);
```

- С помощью clearInterval(interval); и clearTimeout останавливаем таймаут или интервал, присваивая их перменным и вводя название переменной в данные методы

  ```javascript
  const timeout = setTimeout(() => {
    console.log('Привет! ');
  }, 1000);
  clearTimeout(timeout);
  ```

В JavaScript, ... — это оператор rest параметров, который позволяет функции принимать неопределенное количество аргументов и собирать их в массив. Оператор rest параметров используется в определении функции и должен быть указан перед последним параметром функции.

```javascript
function sum(...numbers) {
  return numbers.reduce((accumulator, current) => accumulator + current, 0);
}

console.log(sum(1, 2, 3, 4)); // Выведет  10
```

- Нижние методы есть асинхронные и синхронные(без callback )

```javascript
// Данный метод выводит нзвание документов которые находяться в директории папке и выводит массив из них
fs.readdir(`${__dirname}/files`, (err, files) => {
  console.log(files);
  file = files;
  // Данный метод читает содержимое файла
  // fs.readFile(`${__dirname}/files/${file[7]}`, 'utf-8', (err, data) => {
  // console.log(data);
  // });
  // Данный метод выводит парапетры файла, разм, дату создания и т.д. в объект
  let stat = fs.statSync(`${__dirname}/files/${file[7]}`);
  console.log(stat);
  console.log(stat.isFile()); //выводит true если это файл
  console.log(stat.isDirectory()); //выводит true если это директория
});
```

- Данный метод меняет наименование файла или перемещает его в другое место:

```javascript
const oldPath = 'path/to/oldFile.txt';
const newPath = 'path/to/newFile.txt';
fs.rename(oldPath, newPath, (err) => {
  if (err) {
    console.error(err);
  } else {
    console.log('Файл успешно переименован');
  }
});
```

# Лекция 124 Promises, Async\await==============

- Промисификация превращение функции callbackaimi в функцию с промисами
  Промисы это некий метод который возвращает не данные а промис(некое обещания, что в скром времени он эти данные даст )
- Промис это некий объект с состоянием, воспринимайте промис как некую коробочку

```javascript
//Состояния промисов
// pending-обещание ще не исполнено(промис не зарезолвен)
// fullfield-обещание исполнено(промис зарезолвен)
// rejected -произошла ошибка(промис отменен)
//Синтаксис:
const promise3 = fs.promises.readFile(`${__dirname}/data/32.txt`, 'utf-8');
console.log(promise3);
// Метод then когда промис будет исполнен выполниться метод then. Некая просьба, что когда промисс выполниться запусти callback.
// Просьба-это синхронный код
// Метод catch-ловит ошибку,и получаеться что асинхронка запускаеться но просто выводит ошибку, в случае then она не срабатывает.
а в случае catch это некий обработчик ошибки и код срабатывает и просто эту ошибку можно вывести.
// методы then и catch можно записывать друг за другом(образуя цепочку)
(код просьба : пожалуйса когад придут данные исполни then, если придет ошибка используй catch )
promise3
.then((data3) => {
console.log('Данные:', data3);
})
.catch((err) => {
console.log('Ошибка:', err);
});

```

- если при подклбчение бибилтиотеки FS поставить promises: const fs = require('fs').promises;то в методах их указывать не нужно будет, сразу же
  функции будут выдавать методы ,а не принимать callback. Промисифицированный версии методов FS.
- Если нам нужно выполнить несколько последовательных операций то мы then выстраиваем в цепочку и таким образом избавляемся от callbackов:

```javascript
const fs = require('fs').promises;
fs.readFile(`${__dirname}/clues/entry.txt`, 'utf-8')
  .then((file1) => fs.readFile(`${__dirname}/clues/${file1}`, 'utf-8'))
  .then((file2) => fs.readFile(`${__dirname}/clues/${file2}`, 'utf-8'))
  .then((file3) => fs.readFile(`${__dirname}/clues/${file3}`, 'utf-8'))
  .then((prize) => console.log(prize))
  .catch((error) => console.error(error));
```

- Как решаються задачи с промисами на then ? допустим надоп прочитать послелдовательно 0,1,2 фаил
- сначалао мы читаем самый первый фаил методом(не забываем при подключение бибилиотеки const fs = require('fs').promises; прописывать promises)
- так как метод readFile асинхронный мы не забываем,что в const у нас вернуться не данные а вернеться промисс поэтому мы после метода пишем .then нам позврашаються уже данные которые мы прочитали из файла, можем что нибудь с ними сделать(делаем с ними синхронные операции)
- а дальше допустим нам нужно вновь сделать что-то асинхронное (допусти вновь какие методы fs),поэтому нам вновь нужно вернуть данный промисс написав return перед методом
- а дальше вновь цепочным методом записываем then и опять делаем то что хотим и если вновь нужен асинхронный код, повторяем предыдущие шаги
- если мы вешаем метод catch чтобы обработать ошибку, то нужно понимать куда его ставить. Если поставить его в конец то он поймает ошибку и в ошибка не будет появляться а если его поставить где то в середени то он может поймать ошибку код пойдет дальше выведет на каком то методе undefinв и потом на другом выведет ошибку если ошибка не приходит то catch не запускаеться, в коде он пропускаеться, console.dir(error)-выведет в консоль информацию об ошибке.

```javascript
const promises = [];
for (let i = 0; i < 10; i++) {
  promises.push(fs.readFile(`${__dirname}/data/${i}.txt`, 'utf-8'));
}
const allPromises = Promise.all(promises); //Promises это класс и унего есть статичный метод all, который создает общий промисс (большую коробку) работате тольок с массиовм
// Берем массив промисов и превращаем в один промис, когда все промисы будут исполнены нам данный метод сообщит и тогда в массиве появиться массив всех наших данных
// теперь на нем можно использовать then, получим массив значений
allPromises.then((data) => {
  console.log(data);
});
// Что и сверху но уже сократили. если нужно параллельно запустить несколько асинхронных операций
const promises = new Array(10)
  .fill(0)
  .map((_, i) => fs.readFile(`${__dirname}/data/${i}.txt`, 'utf-8'));
Promise.all(promises).then((data) => console.log(data)) *
  Promise.race(promises).then((data) => console.log(data)); //если нам нужно получить только самого первого

// Если мы наткнулись на метод который не возвращает промис (SetTimeout ), нам нужно создать промис самостоятельно-жто называеться промисификация
const fs = require('fs');
// Это некое обещание которое исполдниться через 1000милисекунд, прошла 1000милисекунд мы вызвали функцию resolve
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve();
  }, 1000);
});
promise.then(() => console.log('Привет! '));
// Создаем промисс
function readFilePromise(file, encoding) {
  return new Promise((resolve, reject) => {
    //создаем самостоятельно промис который должен возвращать одно из состояний fullfield или rejected с помощью аргументов первый возвращает resolve(fullfield) второй rejected
    fs.readFile(file, encoding, (error, data) => {
      if (error) reject(error);
      //если происходит ошибка то промис переходит в состояние rejected
      else resolve(data); // если данные пришли то запускаем функцию resolve() и этот промис переходит в состояние fullfield
    });
  });
}
readFilePromise(`${__dirname}/data/9.txt`, 'utf-8') //данная функция возвращает промис
  .then((data) => {
    //потом уже на этот промис используем метод then и catch
    console.log(data);
  })
  .catch((error) => {
    console.log(error);
  });
```

- async await-это синтаксичейский сахар и под капотом он разворачиваеться в те же самые .then. Работает только с функцией, await ставиться всегда слева от промиса.
  Асинхронная функция всегда возвращает промис, а промис в будущем положиться то что мы возвращаем из асинхронной функции.

```javascript
async function getPrize() {
const data = await fs.readFile(`${__dirname}/clues/entry!!!.txt`, 'utf-8');
console.log(data); //в данном случае данная строчка асинхронная и выполниться только после выполнения промиса1
}
getPrize();

---

async function getPrize() {
try {
const file1 = await fs.readFile(`${__dirname}/clues/entry!!!.txt`, 'utf-8');
const file2 = await fs.readFile(`${__dirname}/clues/${file1}`, 'utf-8');
const file3 = await fs.readFile(`${__dirname}/clues/${file2}`, 'utf-8');
const prize = await fs.readFile(`${__dirname}/clues/${file3}`, 'utf-8');
console.log(prize); //в данном случае данная строчка асинхронная и выполниться только после выполнения промиса1
} catch (error) {
console.log(error);
}
}
getPrize();
```

# Как работать с асинхронным кодом

### Промисификация: Если асинхронная операция работает на callbackах (а не на промисах)

Промисифицируем-создаем новый промис.
В новый промис вкладваем саму операцию,после этого уже можем исользовать метод then на этот промисс.

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi!');
  }, 1000);
});

promise.then((result) => console.log(result)); //hi!
```

### Если асинхронная операция на промисах

**then**

```javascript
const fs = require('fs').promises;

fs.readFile('path', 'utf-8').then((data) => console.log(data));
```

**async/await**
ставим await напротив метода который нам нужно подождать, и присваеваем его значение в константу

```javascript
const fs = require('fs').promises;

async function main() {
  const data = await fs.readFile('path', 'utf-8');
  console.log(data);
}
```

### Если нужно выполнить несколько асинхронных операций последовательно

```javascript
const fs = require('fs').promises;
fs.readFile('path1', 'utf-8')
  .then((data) => {
    console.log(data);
    return fs.readFile('path2', 'utf-8');
  })
  .then((data) => {
    console.log(data);
    return fs.readFile('path3', 'utf-8');
  })
  .then((data) => {
    console.log(data);
  });
```

**async/await**

```javascript
const fs = require('fs').promises;

async function main() {
  const data1 = await fs.readFile('path', 'utf-8');
  console.log(data1);
  const data2 = await fs.readFile('path', 'utf-8');
  console.log(data2);
  const data3 = await fs.readFile('path', 'utf-8');
  console.log(data3);
}
```

### Если нужно выполнить несколько асинхронных операций параллельно

Тогда нужно создать массив промисов

```javascript
const fs = require('fs').promises;

const promises=[
	fs.readFile('path1', 'utf-8');
	fs.readFile('path2', 'utf-8');
	fs.readFile('path3', 'utf-8');
]
  Promise.all(promises).then((data) => {
    console.log(data);
  });
```

**async/await**

```javascript
const fs = require('fs').promises;

async function main() {
	const promises=[
	fs.readFile('path1', 'utf-8');
	fs.readFile('path2', 'utf-8');
	fs.readFile('path3', 'utf-8');
];
  const data =await Promise.all(promises)
    console.log(data);
  };
```

### Конструкция "switch"

Конструкция switch заменяет собой сразу несколько if.
Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

- Важно чтобы передаваемый аргумент в switch и в case были одного типа так происходит строгое сравнение
- break внизу не обязателен, но ставится по «правилам хорошего тона»
- Можно группировать case :

```javascript
//   case 2:
//   case 3:
// 	console.log('Вы ввели число 2, а может и 3');
// 	break;
```

- Примеры:

```javascript
// На switch case
const browser = 'Edge';
switch (browser) {
  case 'Edge':
    console.log("You've got the Edge!");
    break;

  case 'Chrome':
  case 'Firefox':
  case 'Safari':
  case 'Opera':
    console.log('Okay we support these browsers too');
    break;

  default:
    console.log('We hope that this page looks ok!');
}

// на if
if (browser === 'Edge') {
  console.log("You've got the Edge!");
} else if (
  browser === 'Chrome' ||
  browser === 'Firefox' ||
  browser === 'Safari' ||
  browser === 'Opera'
) {
  console.log('Okay we support these browsers too');
} else {
  console.log('We hope that this page looks ok!');
}

// на if
const number = +prompt('Введите число между 0 и 3', '');

if (number === 0) {
  alert('Вы ввели число 0');
}

if (number === 1) {
  alert('Вы ввели число 1');
}

if (number === 2 || number === 3) {
  alert('Вы ввели число 2, а может и 3');
}

//на switch

switch (number) {
  case 1:
    console.log('Вы ввели число 0');
    break;
  case 2:
    console.log('Вы ввели число 1');
    break;
  case 2:
  case 3:
    console.log('Вы ввели число 2, а может и 3');
    break;
}
```

# Лекция 131 SQL==============

- Система управления базами данных, СУБД — специальная программа-сервер позволяющая использовать и управлять базами данных. СУБД позволяет читать и записывать данные, искать по ним и выполнять сложные выборки.

- База данных, БД — фактически создаваемые на диске файлы в которых хранится информация записанная с помощью СУБД

- Реляционная система управления базами данных, РСУБД — СУБД которая хранит данные в виде таблиц и строк в этих таблицах. Любая данные в РСУБД должны быть структурированы в соответствии с реляционной моделью.Примеры РСУБД:● PostgreSQL● MySQL● MS SQL● Oracle
- Реляционная модель данных, РМД — математическая теория лежащая РСУБД, она описывает как мы подходим к структурированию данных, чтобы было легко манипулировать. Именно она требует от нас наличие таблиц, строк и связей между ними.
- Нормализация данных — последовательный процесс преобразования структуры данных таким образом, чтобы она соответствовала реляционной модели.
- Нормальная форма, НФ — набор требований к структуре таблиц и связей между ними. Существует 8 нормальных форм, каждая последующая ужесточает требования по сравнению с предыдущими.Для работы с РСУБД нужно добиться чтобы структура таблиц соответствовала усиленной третьей нормальной форме, которую ещё называют нормальной формой Бойса-Кодда, НФБК
- Первая нормальная форма :
  Не подходит под критерии первой нормальной формы:
  ● Есть дублирующиеся строки
  ● Присутствуют составные значения
  ● Присутствуют массивы
- Вторая нормальная форма : Естественные(присуще объекту)(паспорт, снилс и т.д.) и сурогатные ключи(искуственные)
- Третья нормальная форма : Таблица должна находиться в 2НФ. В таблице должны отсутствовать транзитивные зависимости. Зависимости одних неключевых столбцов от других.
- НФ Бойса-Кодда: Таблица должна находиться в 3НФ. В таблице должны отсутствовать зависимости ключевых столбцов от неключевых столбцов.
- Structured Query Language, SQL — декларативный язык программирования,предназначенный для описания изменения и извлечения данных из СУБД. Чаще всего используется в реляционных СУБД.
- Типы данных в SQL:

- Числа:
  ● serial — целое с автоувеличением, от 1 до 2147483647;(для ID )

● smallint, int2 — целое, от -32768 до +32767;

● integer, int, int4 — целое, от -2147483648 до +2147483647;

● bigint, int8 — целое, от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807;

● double precision, float8 — с плавающей точкой, от 1E-307 до 1E+308

-Строки:
● character(n), char(n) — представляет строку из фиксированного количества символов. С помощью параметра задается задается количество символов в строке;(фиксированое количество символов)

● character varying(n), varchar(n) — представляет строку из фиксированного количества символов. С помощью параметра задается задается количество символов в строке;(динамическое символов)

● text — представляет текст произвольной длины.(влияет на индексацию и скрость доступа к данным и поиска по ним)
-Время и даты:
● timestamp — хранит дату и время, с учётом часового пояса или без. Для дат самое нижнее значение 4713 год до н. э., самое верхнее значение 294276 год н.э.;

● date — представляет дату от 4713 год до н. э. до 5874897 года н.э;

● time — хранит время суток, без даты, с учётом часового пояса или без. Принимает значения от 00:00:00 до 24:00:00.

-Другое:
● boolean — булево значение, true или false
● jsonb — данные произвольного формата в формате JSON

- Создаем базу данных в терминале posgresSQL:
  CREATE USER test_user WITH PASSWORD 'qwerty'; Пользователь создаётся именно в СУБД!
  CREATE DATABASE test_db OWNER test_user;Любая база должна быть создана, прежде чем к ней можно будет подключиться.
  GRANT ALL PRIVILEGES ON DATABASE test_db TO test_user; По умолчанию доступ к базе имеет только owner и супер-администратор СУБД. Всем
  остальным пользователям доступ нужно добавлять явным образом.
- DROP DATABASE test_db; Удалить базу данных может её владелец, супер-администратор СУБД или
  пользователь, которому явным образом даны на это права.
- CREATE TABLE groups (
  id serial PRIMARY KEY,
  nаme varchar(80) UNIQUE
  ); При создании таблицы нужно указать её название и все входящие в неё столбцы. Не
  забудьте указать первичный ключ!
- INSERT INTO students (name, age) VALUES
  ('Anna', 25),
  ('Maria', 23),
  ('Roman', 28); добавление строк в таблицу.
- SELECT name, age FROM students;
  SELECT _ FROM students WHERE age < 18;
  SELECT _ FROM students ORDER BY age ASC;
  SELECT AVG(age) AS 'Средний возраст' FROM students;

С помощью SELECT можно не просто вытаскивать данные, но и проводить
фильтрацию, сортировать и проводить несложные агрегации.

- UPDATE students SET age = 26 WHERE name = 'Anna';
  С помощью UPDATE можно изменять любые данные в таблице.
  Использование WHERE не обязательно, хотя и крайне рекомендуется. Без
  WHERE будут обновлены все существующие строчки в таблице.

- DELETE FROM students WHERE id = 1;
  Чаще всего удаление происходит по id, но можно удалять и по любому другому полю:
  DELETE FROM students WHERE name = 'Anna';
  Возможно использование DELETE вообще без WHERE, в таком случае будут удалены
  вообще все данные в таблице.

# Лекция 211 HTTP,Express, React SSR==============

- Сервер — программа, способная принимать и обрабатывать
  запросы от других программ.

- Клиент — программа, которая отправляет запросы серверу и
  получает от него ответы.

- Протокол — набор правил, по которым сервер и клиент
  обмениваются данными и “понимают” друг друга.

Клиент и сервер могут взаимодействовать друг с другом в
рамках:
● одного компьютера,
● локальной сети или
● или целого интернета.

- HyperText Transfer Protocol, HTTP — текстовый протокол,
  разработанный для передачи HTML.Сейчас используется для передачи любой информации между веб-сервером и браузером.Вы пользуетесь HTTP каждый раз, когда открываете любой сайт в интернете. HTTP используеться для передачи любьой информации, в этом протоколе все данные передаються в виде строки.

- Имя и адрес ресурса в сети, включает в себя URL и URN

URI: https://somesite.ru/images/logo.png

Адрес ресурса в сети, определяет местонахождение и способ обращения к нему

URL — https://somesite.ru

Имя ресурса в сети, определяет только название ресурса

URN — images/logo.png

Анатомия URL
http://example.com:8080/some/path?showResp=1&path=no
└┬─┘ └────┬──┘ └┬─┘└──┬───┘└─┬───────────────┘
Протокол Хост Порт Path Query

Стартовая строка
GET /about.html HTTP/1.1
└┬┘ └┬──────┘ └┬────┘
│ Path Версия протокола
│
Метод запроса

- HTTP-метод (HTTP-глагол) Желаемое действие над веб-ресурсом, которое запрашивает клиент - прочитать, записать, удалить и т. д. Реализация этого действия зависит от веб-сервера.У каждого из методов есть назначение.

● GET — получить данные (Read)
● POST — отправить данные (Create)
● PUT — изменить данные (Update)
● DELETE — удалить данные (Delete)

Структура запроса
GET /students HTTP/1.1 ─ стартовая строка
Host: school.example ┐
Accept-Language: ru-ru ├ заголовки
User-Agent: Mozilla/5.0 ┘
(пустая строка)
(тело запроса — пустое или с данными)

Строка статуса
HTTP/1.1 200 OK
└┬───┘ └┬┘ ├┘
│ │ Текст кода ответа
│ Код ответа
Версия протокола

- Коды ответа поделены на группы по смыслу:
  1** информационные коды
  (например, смена протокола с HTTP на WebSocket)
  2** всё хорошо, запрос выполнен успешно
  3** переадресация, сервер просит перейти на другую страницу
  4** ошибка со стороны клиента
  (запрошен несуществующий адрес, переданы некорректные данные и т. д.)
  5\*\* ошибка со стороны сервера
  (сервер не смог обратиться к базе данных или другая внутренняя ошибка)

Примеры кодов ответа

● 200 — всё ок, запрос выполнен успешно
● 201 — объект создан успешно
● 403 — доступ к данным запрещён
● 404 — запрошенные данные не найдены

MIME type

- Описание типа данных, передаваемых по сети. Например:
  ● text/plain — простой текст
  ● text/html — HTML-документ
  ● application/json — данные в JSON-формате
  ● application/xml — XML-документ
  ● multipart/form-data — бинарные данные

- Установка Babel и React:
- Babel позволяет подключать jsx файлы (JavaScript, в котором можно писать HTML).
  npm install @babel/core @babel/preset-env @babel/preset-react @babel/register react react-dom
  Чтобы подключить Babel в главном js-файле сверху нужно добавить строчку:
  require('@babel/register');
  В корень проекта нужно добавить файл “.babelrc” с таким содержимым:
  {
  "presets": ["@babel/preset-env", "@babel/preset-react"]
  }

- Автоматически перезапускает сервер при изменении файлов для удобства разработки.
  Установка: npm i -D nodemon
  Настройка отслеживания файлов: --ext js,json,jsx
  Вместо node server.js пишем nodemon server.js

- Create, Read, Update, Delete (CRUD): Это основные операции, которые выполняются с базами данных. CRUD - это акроним, который обозначает четыре базовые функции: создание (create), чтение (read), обновление (update) и удаление (delete). Эти операции являются основой для работы с базами данных и используются во многих областях информационных технологий 2, 4

# Лекция 214 Fetch APi============

Asynchronous Javascript and XML

- Ajax — подход в веб-разработке для асинхронного обновления страниц.
  ● Запросы на сервер асинхронные → страница не заблокирована
  ● Не нужно заново выполнять все скрипты
  ● Отрисовываем только то, что изменилось

- Fetch API — одна из реализаций подхода Ajax.
- в когда подключаем js в html через script нужно прописывать defer, чтобы JS открывался после прочтения html
- пакет axios аксисос, чтобы меньше писать инфы в fetc запросах
  npm i axios

  ```javascript
  //отправляем сообщение на сервер
  const form = document.getElementById('message-form');
  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    try {
      await axios.post('/api/messages', {
        name: form.name.value,
        text: form.text.value,
      });
      form.text.value = '';
      //form.reset(); //сбрасывает введеные значения в форме
    } catch (error) {
      console.error(error);
    }
  });
  ```

- если не хочеться подключать пакет через npm можно ввести название пакета с абревиватурой cdn и подключить в layoute через script

```javascript
// Отправить GET запрос по указанному URL
fetch('https://some-url.example');

// Отправить POST запрос по указанному URL
fetch('https://some-url.example', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    //отправка тела ,а именно объекта в формат JSON. Стрингифицируем объект, переделываем объект  в формат строки для отправик на сервер в формате JSON.
    myKey: 'my value',
  }),
});

// Отправить GET запрос по указанному URL
const response = await fetch('https://some-url.example');
// в response попадает информация так сказать не в чистом виде как отдал сервер а весь ответ в полном его виде(статусы и много всего и тело ответа)

// Прочитать тело ответа в JSON-формате
const body = await response.json();
//.json и text это методы которые тоже возвращают промисс,в bode попадает информация так сказать чистая,согласно тому формату которую отдал сервер(в body тот ответ который ранее был написан в обработчики на сервере )
// Методы чтения тела ответа (json, text, и т. д.) возвращают объект Promise.
// Прочитать тело ответа можно лишь один раз!
```

-В JSON должны быть обязательно двойные ковычки

```javascript
//на стороне сервера
res.json({ created: true, message: 'Student added' });

//<form id="form" method="POST" action="/students"></form>; - у ас есть некая форма в которой указан метод передачи информации
// POST, ссылка куда она будет передоваться
const p = document.querySelector('#info');
// присваеваем в переменную form и вещаем обработчик на submit
const form = document.querySelector('#form');
form.addEventListener('submit', async (event) => {
  // отмена дефолтного поведения
  event.preventDefault();
  //деструктуризируем из формы путь и метод передачи и передача значений inputov с name
  const { action, method, name, age } = event.target;
  const response = await fetch(action, {
    method,
    headers: {
      'Content-Type': 'Application/json',
    },
    body: JSON.stringify({
      name: name.value,
      age: age.value,
    }), //переводим данные в строку, на сервере происходит обратное JSON.parse() обратный перевод из строки в начальный тип
  });

  const data = await response.json(); //это метод через которые сервер возвращает ответ,он возвращает промис
  //и уже в data  мы получили настоящий ответ, без методанных ,без статусов чистый ответ
  //Выводим на стороне клиента напдись что данные добавлены
  if (data.created) {
    p.textContent = data.message;
  }
  console.log(data);
});
```

# Лекция 214 Docker==========================

- npm ci -запускает версии пакеов которые прописаны в package.json(на основе которых создавался код)
- docker -v -узнаем версию докера
- создаем фаил Dockerfile (инструкция для создания образа) и прописываем слудующую информацию:

```javascript
FROM node  //указаываем на чем будет создаваться базовый образ, в данном случае на самом  свежей версии node

WORKDIR /app //Задаём текущую рабочую директорию

COPY package.json .
COPY package-lock.json .

RUN npm ci //установка пакетов из файла package.json

COPY . . //Копируем код из локального контекста в рабочую директорию образа

EXPOSE 4000 //Открываем порты

CMD [ "npm", "start" ]

```

- создаем фаил .dockerignore:

```javascript
*/node_modules
*/.git
```

- Эта команда создаёт контейнер из образа и запускает его:
  docker run --name fetch-container-3 -p 4000:4000 fetch-image

# Лекция 221 REST API==========================

API-(application programming interface) программный интерфейс приложения

- REST API (Representational State Transfer Application Programming Interface) - это архитектурный стиль для построения веб-сервисов. Он предоставляет стандартные соглашения и ограничения для создания веб-служб, что облегчает их взаимодействие между собой.

Основные принципы REST включают:

1. Ресурсы (Resources): Каждый компонент системы представляется в виде ресурса, к которому можно обращаться через уникальный идентификатор (например, URL).

2. Представление (Representation): Ресурсы могут иметь различные представления (например, JSON, XML), и клиент может выбирать представление, которое наилучшим образом соответствует его потребностям.

3. Статус (Stateless): Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для понимания и обработки запроса. Сервер не должен хранить состояние между запросами от одного клиента.

4. Интерфейс однозначности (Uniform Interface): Интерфейс взаимодействия между клиентом и сервером должен быть однозначным. Это обеспечивает упрощение и унификацию архитектуры.

5. Несвязанность (Statelessness): Каждый запрос клиента к серверу должен содержать всю необходимую информацию для понимания и обработки запроса. Сервер не должен хранить состояние между запросами от одного клиента.

REST API часто используется в веб-разработке для создания веб-служб, предоставляющих данные и функциональность для взаимодействия с другими приложениями или сервисами. Взаимодействие с REST API осуществляется посредством HTTP-запросов, таких как GET, POST, PUT и DELETE.

Концепции REST API по Ulbi TV:

1. Модель взаимодействия клиент-сервер
2. Stateless Отсутсвие состояния (сервер не хранит состояние между запросами, клиент и сервер общаються как в первый раз)
3. Единообразный унифицированный интерфейс (интерфейс взаимодействия между клиентом и сервером должен быть однозначным)
4. API может быть кешированным
5. Формат обмена данными чаще всего JSON или XML

6. API должно быть версионированным (и каких обратных не совместимых действий не должно быть)
7. API должна быть задокументированной
8. Система может быть многоуровневой или многослойной(API на сервере для функционирования может использовать другие серверы )

SOAP это протокол для обмена данными между клиентом и сервером, работает на XML.
GraphQL — это открытый стандарт для API, который предоставляет более эффективный и гибкий подход к взаимодействию с данными по сравнению с традиционными REST API. Вместо того чтобы иметь множество конечных точек (endpoints) для различных ресурсов, как в REST, GraphQL использует единую конечную точку, которая позволяет клиентам определять структуру данных, которую они хотят получить.

Основные особенности GraphQL включают:

Определение запросов: Клиенты могут запрашивать только те данные, которые им нужны, указывая их в запросе. Это уменьшает объем передаваемых данных и улучшает производительность.
Типизация: Все данные в GraphQL строго типизированы, что позволяет клиентам знать, какие поля доступны для каждого типа данных.
Обработка запросов: Сервер обрабатывает запросы GraphQL и возвращает данные в формате JSON. Это упрощает интеграцию с различными клиентами и платформами.
Обновление данных: GraphQL позволяет клиентам обновлять данные с помощью одного и того же запроса, что упрощает синхронизацию данных между клиентом и сервером.
Интроспекция: GraphQL поддерживает интроспекцию, что позволяет клиентам изучать схему API и понимать, какие запросы и типы данных доступны.
Пример запроса на GraphQL может выглядеть так:

query {
user(id: 1) {
name
email
posts {
title
content
}
}
}

# Лекция 222 Cookies, Session==========================

- Cookies печеньки крошки, которые оставил после себя пользователь, храняться только в браузере, привязаны к хосту, домену.

- Обычно используется для:
  ● аутентификации пользователя
  ● хранения сессии
  ● хранения корзины, игровой статистики, etc.
  ● хранения личных настроек
  ● сбора статистики о пользователях

- Сессионная кука, работает пока открыт браузер, потом удаляеться (/ корневая кука работает на всех страничках страницы), по умолчанию куки вешаеться на корень, но можно задать путь path:
- Срочная кука, Можно задавать {maxAge }и задать время жизни куки по времени.А можно задать датой expires:.
  -Можно сделать куку приватной прописав на сервере httponly, на JS ее видно не будет. Через клиент мы ее не получим document.cookie, не можем ее спарсить.
  -Можно ставить куки с сервера и с клиента.

- Сессия тоже данные связанные с определенным посетителем, но хранящиеся на сервере. На клиент обычно передаётся id сессии – случайная строка,
  зашифрованная по секретному слову, которая хранится в cookie. Сессия создает автоматчески куку.

  _cookie_

```javascript
document.cookie = 'cookie2=aidarkykan2';
document.cookie = `cookie2=${encodeURIComponent('aidar syper')}`; // правильная кодировка когда используеться пробелы и другие символы
//поумолчанию cookie живут до закрытия бразуера это sessionые куки, но мы можем задавать параметры жизни куки самостоятельно max-age=3 (передаем колличество секунд)
document.cookie = `cookie2=${encodeURIComponent('aidar syper')}; max-age=3`;
//удаляем вручную куки
// document.cookie = `cookie2=${encodeURIComponent('aidar syper')}; max-age=-1`;
console.log(document.cookie);
```

_localStorage, sessionStorage_

```javascript

- localStorage.setItem("name","Artist")-создаем хранилище которая будет существовать пока мы его не удалим
- let storage=localStorage.getItem("name")-после добавления данных в storage мы можем ее получить
- localStorage.removeItem("name")-после добавления данных в storage мы можем ее получить
- localStorage.clear()-удаляем все данные из localStorage
- sessionStorage.setItem("name","Artist")-создаем хранилище которое будет существовать пока сущ.сессия

//сохранение объектов и массивов в localStorage и взятия оттуда

const user = { name: 'AidarКрут', age: 24 };
localStorage.setItem('user', JSON.stringify(user));
const storedUser = JSON.parse(localStorage.getItem('user'));
console.log(storedUser.name);


```

# Лекция CORS====================

- Данные по протоколы http шифруються на бэке, а не в момент отправки POST, а https шифруються во время передачи.
- если мы отправляем fetch запрос на сторонний сервер то нам нужно указывать в нем credentials: 'include', чтобы вместе с запросом уходил куки.

# Лекция Deploy====================

- в фаил .env мы указываем переменные а в них указываем данные которые нам нужно скрыть(DATA base, PORT).

# Лекция 231 WebSockets====================

чтобы постоянно отражалась актуальное состояние приложения

```javascript
//подтянули сервер
// const socketClient = new WebSocket('ws://localhost:3000/');
// лучше делать так чтобы все корректно работало
const socketClient = new WebSocket(
  window.location.origin.replace(/^http/, 'ws')
);

//отправляем сообщение на сервер
const form = document.getElementById('message-form');
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  //  try {
  //    await axios.post('/api/messages', {
  //      name: form.name.value,
  //      text: form.text.value,
  //    });
  //    form.text.value = '';
  //    //form.reset(); //сбрасывает введеные значения в форме
  //  } catch (error) {
  //    console.error(error);
  //  }
  // отправка запроса через webSocket, без  async потому что мы не принимаем ответ, а бросаем просто в пустоту
  socketClient.send(
    JSON.stringify({
      name: form.name.value,
      text: form.text.value,
    })
	 form.text.value = '';
  );
});

// повесили слушителя, ловим сообщения с сервера и отображаем у всех клиентов на странице отправляя html код
socketClient.addEventListener('message', (event) => {
  const { name, text } = JSON.parse(event.data);
  const messageHTML = `
  <div class="message">
 <div class="message-name">${name}</div>
 <div class="message-text">${text}</div>
  </div>
  `;

  document
    .querySelector('.message-container')
    .insertAdjacentHTML('afterbegin', messageHTML);
});
```

<!-- для мобилки -->

meta name="viewport" content="width=device-width,
initial-scale=1,0"

# Лекция 234 Intro React====================

- npx create-react-app . установка клиентского реакта в текущую папку с помощью пакета npx create-react-app (это пакет с пакетами) - это просто сборка из Webpacka (это такая штука которая собирает все файлы и упаковывает в один фаил, react, babel, eslint )

-      устонваливает для typescripta (в пакеты входит: React, React DOM, babel для работы jsx, gitignore, )

- npm run start
- когда react на клиенте импорт библиотек происходит через import React from 'react', export default App (если все один экспорт); Если же много то:
- import logo from './logo.svg'; // в лого попадает путь к картинки и уже ее можно вставлять кудато. Просто путь нельзя указывать так как в папке public они не будут отобрадаться, а так webpack сам их будет указаывтаь

```javascript
export function sum(a, b) {
  return (a = b);
}
export const x = 1;
export default class MyClass {}

// имортируем файлы из другога js файла
import { sum, x } from './utils';
import MyClass, { sum, sum, x } from './utils';
```

- webpack дает возможность подключать различные файлы не только js из javascripta напрмире CSS

- в реакте все события начинающиейся с on можно отследить <button onClick={}>+</button>
  -В typescripte задаем событию event тип <HTMLInputElement>,чтобы было понятно что это за тип данных:

```javascript
function handleChange(event: React.ChangeEvent<HTMLInputElement>) {
  const value = event.target.value;
  setStep(Number(value));
}
```

- typescript нужен для того чтобы код содержал как можно меньше ошибок времени исполнений (run time errors)(ошибка которую мы определяем не сразу а спустя какое-то время) и ошибок времени компиляции (compiled time errors)(ошибка которая мы увидели до запуска приложения, увидели ее в коде). Цель typescripts перевести шибки времени исполнения в ошибки времени компиляции с помощью того, что typescript знает где какой тип у каждой переменной .
- Чаще всего задаються типы параметров функции и результатов функции, и не задються типы переменных и констант, так как они задаються автоматически

```typescript
//можно задвать типы не явно
let arr = [1, 2, 3]; //массив элементов и каждый тип number
arr.push(5);
// arr.push('abc'); //пушить другой тип данных мы не можем

let arr2 = [1, 2, '3']; //массив элементов и каждый тип union(совмещенный (string | number)[] ,либо строка либо число)
arr2.push(5);
arr2.push('abc');

let arr3; // получился тип данных any так писать нельзя. Очень вредный тип, можно писать что хочешь обычный JS ? теряеться суть в TS.
arr3 = [1, 2, 3];

//можно задавать типы явно,
const a: number = 0;
const b: string = 'abc';
const c: boolean = true;
let d: number | null = null; //| значек или на типах, можно и number и null
const e: Date = new Date();
const f: string[] = ['a', 'b']; // массив строк

//Функции
function sum(a: number, b: number): number {
  //очень рекомендуеться указывать тип который возвращает функция после скобок, (a: number, b: number) а здесь происходит проверка на вызове функции с переданными аргументами
  return a + b;
}

const s = sum(1, 2);

const makeArray = (a: number): [number, number, string] => [a, a, a.toString()]; //это именно массив из трех чисел (кортеж-из контректного количество элементов, где элемнты могут быть разного типа)
console.log(makeArray(2));

// може создавать Собственные типы

//union-types (тип сумма)
type Gender = 'male' | 'female' | 'non-binary'; //создаем свой тип данных,принято типы писать с большой буквы

let gender: Gender = 'male'; //присваевыаем созданный тип переменной, где можем выбрать только 3 условных типа
gender = 'female';

type ExtendedGender = Gender | 'androgyne' | 'genderfluid'; //создаем свой тип данных, из Gendera и новых типов

//тип объекта (интерфейс)
interface User {
  name: string;
  surname: string;
  //можем указывать  необязательные свойтва
  middleName?: string; //отчество тип данных который может быть а может и не быть,string | undefined
  gender: Gender;
}

//void -функция ничего не возвращает
function renderUser(user: User): void {
  //void означает что функция ничего не возвращает
  const middleName = user.middleName; //string | undefined
  console.log(
    `${user.name}   ${user.surname} ${user.middleName?.toUpperCase()} ${user.gender.toUpperCase()}`, //{user.middleName?.toUpperCase= user.middleName && user.middleName.toUpperCase
  );
}

const user: User = {
  name: 'Vitalya',
  surname: 'Googlovich',
  //   middleName: 'ReactKing',
  gender: 'male',
};

renderUser(user);

//inline types, если испоьзуешь для одной переменной
let gender2: 'male' | 'female' | 'non-binary' = 'non-binary'; // можно вместо того чтобы добовлять тип отдельно вшивать сразу в переменную
let user3: { name: string } = { name: 'Baga' };

//тип функции
type MyFunc = (a: number, b: number) => string;
let myFunc: MyFunc;
myFunc = (a, b) => (a + b).toString();

//обнуляемые типы
let user4: User | undefined;

user4 = { gender: 'female', name: 'Masha', surname: 'Vitalevna' };
user4 = undefined;

//приведение типов
const div = document.querySelector('#div');
if (div) {
  //проверяем что у нас вернулся не тип null
  div.remove(); //удаляем элемент со страницы
}

const div2 = document.querySelector('#div')!; //я гарантирую что здесь что-то есть (типо отвечаю!!!), небезопасное приведение типов(если мы уверены на 100%)
div2.remove(); //удаляем элемент со страницы

const form = document.querySelector('#form') as HTMLFormElement; //чтобы нам скaзать что здесь точно form используем оператор приведения типов as
form.reset();

const form2 = document.querySelector('#form');
if (form2 instanceof HTMLFormElement) {
  //используем оператор instanceof для проверки. На самом деле HTMLFormElement это класс дом элемента form2
  form2.reset();
}

export {};
```

- реакт компоненты никогда не могут быть ассинхронными поэтому через async их писать нельзя, пишем через then
- const [repos, setRepos] = useState<Repository[]>([]); -переменная состояния. Ее мы используем когда с сервера нам приходят динамичные данные , мы не знаме сколько их может прийти поэтому используем переменную состояния.setRepos() - это функция для изменения переменной состояния. <Repository[]>-тип данных

```typescript
import { useEffect, useState } from 'react';
import React from 'react';

interface Repository {
  id: number;
  name: string;
  description: string;
}

function GitRepos() {
  const [repos, setRepos] = useState<Repository[]>([]); //всегда задавать значение по умолчанию, типизируем переменную состояния
  useEffect(() => {
    // если намнужно использовать fetch в компоненте, то нам нужно использовать хук UseEffect. Этот хук запуститься толье=ко один раз при первой отрисовки компонента
    fetch('https://api.github.com/users/AidarSm/repos')
      .then((result) => result.json())
      .then((data) => setRepos(data));
  }, []);

  return (
    <div>
      <ul>
        {repos.length === 0
          ? 'loading...'
          : repos.map((repo) => (
              <li key={repo.id} style={{ color: 'black' }}>
                {repo.name} ({repo.description})
              </li>
            ))}
      </ul>
    </div>
  );
}

export default GitRepos;
```

# Лекция 311 Intro React====================

CREATE-REACT-APP=React+Babel+Webpack+Eslint+Jest+TypeScript-Сборка для установки библиотек

1. Создаем фронтенд

```bash
npx create-react-app frontend --template typescript

```

2. Копируем секцию eslintConfig в package.json(добавляем правила для ts и убираем не нужные)

   "eslintConfig": {
   "extends": [
   "react-app",
   "react-app/jest",
   "airbnb",
   "airbnb-typescript"
   ],
   "rules": {
   "jsx-a11y/interactive-supports-focus": 0,
   "jsx-a11y/control-has-associated-label": 0,
   "react/jsx/indent": 0,
   "implicit-arrow-linebreak": 0,
   "@typescript-eslint/indent": 0,
   "@typescript-eslint/comma-dangle": 0,
   "function-paren-newline": 0,
   "no-param-reassign": 0,
   "no-nested-ternary": 0,
   "no-confusing-arrow": 0,
   "operator-linebreak": 0,
   "jsx-a11y/anchor-is-valid": 0,
   "jsx-a11y/label-has-associated-control": 0,
   "react/jsx-one-expression-per-line": 0,
   "jsx-a11y/click-events-have-key-events": 0,
   "default-case": 0,
   "@typescript-eslint/default-param-last": 0,
   "@typescript-eslint/switch-exhaistiveness-check": 0,
   "@typescript-eslint/explicit-function-return-type": [
   2,
   {
   "allowExpressions": true,
   "allowTypedFunctionExpressions": true,
   "allowHigherOrderFunctions": true,
   "allowDirectConstAssertionInArrowFuctions": true
   }
   ],
   "no-await-in-loop": 0,
   "@typescript-eslint/consistent-type-definitions": [
   "error",
   "interface"
   ],
   "consistent-return": 0,
   "object-curly-newline": 0,
   "@typescript-eslint/no-use-before-define": 0,
   "jsx-a11y/no-static-element-interactions": 0,
   "react/jsx-no-bind": 0,
   "import/pefer-default-export": 0
   },
   "parserOptions": {
   "project": [
   "tsconfig.json"
   ]
   }
   },

3. Устонавливаем eslint-плагины `npm i eslint eslint-config-airbnb eslint-config-airbnb-typescript eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks -D`

- cd frontend - переход в папку через терминал
- typeScript: Reastart TS server -перезагружаем ts в с+shift+p
- асинхронные функции всегда возрващают промисс
- import \* as api from './api'; //все методы положили в объект api и их можно овызвать через точку

4. Исправить скрипт:
   `"start": "set ESLINT_NO_DEV_ERRORS=true && react-scripts start"`убираем вывод ошибки на экране
   <React.StrictMode>//данная тема показывает больше возможных ошибок, но бывают баги с двойным прокидыванием fetch или что-то еще
   <App />
   </React.StrictMode>
   `"start": "cross-env ESLINT_NO_DEV_ERRORS=true react-scripts start",`
   ` npm install --save-dev cross-env`

5.Изменить найстройку `eslint.workingDirectories`, чтобы подружить VScode и ESLint (смотри папку `.vscode`)

6.Удалить папку `frontend/.git`

7.Устанавливаем экспресс-сервера в папку backend

8. `В frontend/package.json` добавляем секцию `"proxy":"http://localhost:4000/"`-мы как бы говоримсерверу каждый раз когда к тебе будет приходить fetch запрос отсылай его на http://localhost:4000// Прокси означает что теперь fetch кидаем не на `'http://localhost:4000/api/students'` а на `'/api/students'`

-Типизация event
для мышки (mouse) -React.MouseEvent,
для form - React.FormEvent,
для input - React.ChangeEvent ,
для кнопки(button, a, div)- React.MouseEvent

- Чтобы взять значение из input нам нужна пара вот этих атрибутов value={}-значение onChange={}-та функция которая запускаеться когда input меняеться. input всегда нужно связывать с переменной состояния, если есть input всегда есть useState

-функция реакт компонент запускаеться не один раз, а запускаеться много раз. Она запускаеться каждый раз когда изменяеться любая переменная состояни , либо меняеться пропсы ее.

9. Для CSS модулей установить модуль `npm i typescript-plugin-css-modules -D` и в секции "compilerOptions" в файле 'tsconfig.json' укажем опцию `"plugins": [{ "name": "typescript-plugin-css-modules" }]`

10. Установка пакета SASS npm install -D sass

11. npm install normalize.css — это набор обнуляющих стилей, которые помогают сделать стилизацию веб-страниц более предсказуемой и последовательной между различными браузерами

@import '~normalize.css/normalize';

12. Реакт роутер дом npm i react-router-dom @types/react-router-dom

13. Пакет для установки redux Ulbi TV npm i @types/react-redux redux react-redux redux-thunk axios

# Лекция 312 React Hooks====================

### Virtual DOM

- Virtual DOM. Реакт сначало строит виртуальный дом, потом на основе виртуального строит реальный дом и когда у нас при изменениие перменной состояния функция компонента вновь запускаеться реакт сравнивает свой старый вирутальный дом с новым, видит различия и только их точечно меняет(это секрет скорости реакта, реакт одинз из самхы быстрых фреймворков для отображения пользовательского интерфейса). Это называеться виртуальным домом, это те дом элементы которые он хранит у себя впамяти для того чтобы их сравнивать между собой и изменять только то что поменялось. Виртуальный дом храниться в оперативной памяти и при обновлении страницы все сбрасываеться.

### useEffect

- useEffect позволяет выполнить функцию на одном из трех этапов жизненого цикла компонента. Три этапа : Mount, Update(props, state , context), Unmount / установка на страницу, когда у компонента что-то меняеться(две веши: либо состояние, либо пропсы, либо контекст), смерть компонета (исчезновения компонента со страницы)

- каждый раз когда мы понимаем,что у нас что-то должно меняться в отображении это значит что нужно создавать какой нибудт useState

-Побочные эффекты - любые действия которые изменяют что-то в окружающем мире называються побочными эффектами.

```javascript
//mount: useEffect(()=>{},[]) - callback запуститься один раз , при изменении переменной состояния запускаться не будет
//update:useEffect(()=>{},[a,b,c]) - будет запускаться каждый раз когда будем менять переменнуя состояния, которую мы указали []
//unmount: useEffect(return ()=>{...},[]) - при удалении из дерева дом компонента будет запускать return и выполнять callback указанный в нем

//Условный рендеринг, если shoWcounter true то мы показываем компонент <Counter />
const [showCounter, setShowCounter] = useState(true);
const hideCounter = (): void => {
  setShowCounter(false);
};
{
  showCounter && <Counter />;
} // условный рендеринг

import { useEffect, useState } from 'react';

export default function Counter(): JSX.Element {
  const [count, setCount] = useState(0);
  console.log('Function start', JSON.stringify({ count }));

  // mount
  useEffect(() => {
    const interval = setInterval(() => {
      console.log('tick');
      setCount((x) => x + 1);
    }, 1000); //в данному случае callback вызываеться самый первый раз, но так как нет зависимостей он больше не вызываеться

    //unmount
    //функция очистки, выполняеться тогда когда компонент будет уничтожен. Типо когда компонент удалиться выполни вот этот код
    return () => {
      console.log('unmount');
      clearInterval(interval);
    };
  }, []); // в данному случае callback вызываеться самый первый раз, но так как нет зависимостей он больше не вызываеться, но навtшиваеться setinterval

  //mount+update
  useEffect(() => {
    console.log('update');

    const timeout = setTimeout(() => {
      console.log('setCount');

      setCount((x) => x + 1);
    }, 1000);

    // очищаем предыдущий tiomeout перед запуском следующего эффекта
    return () => {
      clearTimeout(timeout);
      console.log('clear');
    };
  }, [count]); //массив зависимостей
  //callback будет вызван каждый раз при изменении count

  function addCount(): void {
    setCount((x) => x + 1);
  }
  return (
    <div>
      {count}{' '}
      <button type="button" onClick={addCount}>
        +
      </button>
    </div>
  );
}
```

- callback в пропсах всегда именубться onUpdate, onRemove
- переменные состояния относящиеся к inputam не выносяться отдельно, всегда храняться в компонентах это гораздо удобнее
- хук это просто функция, которая называеться со слова use. В хуках можно писать другие хуки.

```javascript
const initialState: StudentsListState = { students: [] };

export default function StudentsList(): JSX.Element {
  //   const [arrStudents, setArrStudents] = useState<Student[]>([]);
  const [state, dispatch] = useReducer(reducer, initialState);
  const { students } = state;
  const [name, setName] = useState('');
  const [age, setAge] = useState('');
  console.log(name, age);

  //READ
  useEffect(() => {
    api.loadStudents().then((students) => setArrStudents(students));
  }, []);

  //DELETE
  function handleRemove(studentToRemove: Student): void {
    //  setArrStudents(arrStudents.filter((s) => s !== studentToRemove)); //в сеттер передаем новое значение, не через функцию если мы не используем старое значение;
    setArrStudents((students) => students.filter((s) => s !== studentToRemove)); //в сеттер передаем функцию, если новое значение основанное на старом;
  }

  //CREATE
  //для мышки -React.MouseEvent, для формы - React.FormEvent, для input - ReactChangeEvent , для кнопки- React.MouseEvent
  function handleSubmit(event: React.FormEvent): void {
    event.preventDefault();
    setArrStudents((students) => {
      const student: Student = {
        id: students.length + 1,
        name,
        age: Number(age),
      };
      return [...students, student];
    });
  }

  //UPDATE
  const handleUpdate = (student: Student): void => {
    setArrStudents((students) => {
      return students.map((x) => (x.id === student.id ? student : x));
    });
  };
  return (
    <div className="students-list-container">
      <form onSubmit={handleSubmit} action="#">
        <input
          placeholder="Student name"
          value={name}
          onChange={(event) => setName(event.target.value)}
        />{' '}
        <input
          type="number"
          placeholder="age
		  "
          value={age}
          onChange={(event) => setAge(event.target.value)}
        />{' '}
        <button type="submit">OK</button>
      </form>
      <ul>
        {arrStudents.map((student) => (
          <StudentsRow
            key={student.id}
            student={student}
            onRemove={handleRemove}
            onUpdate={handleUpdate}
          />
        ))}
      </ul>
    </div>
  );
}
```

### Отделяем данные от представления

-Есть два варианта либо это отдельный хук либо useReducer(более мощный)

```javascript
//USEREDUCER-переносим те функция которые мы можем совершать с данными в отдельную функцию reducer, для сокращения и читаемости кода
1.Типизируем начально состояние.Описываем начальное состояние компонента.выносим состояние на основе которго строиться наш компонент
import Case from './Case';

export default interface TodoState {
  tasks: Case[];
}
2. Типизируем Action, задаем type и payload.
type Action =
  | { type: 'tasks/loadTasks'-наименование раздела/само действием которое мы совершаем; payload: Case[] }
3. Создаем функцию reducer где прописываем  конструкцию switch case и выносим в них действия пользователя из компонента.
function reducer(state: TodoState, action: Action): TodoState {
  switch (action.type) {
    case 'tasks/loadTasks': {
      return { ...state, tasks: action.payload };
    }}}
4. Заменяем в коде компонента все useState (где хранилось начальное значение приходящего fetcha) на dispatch({type:/payload})
 //update
  const handleUpdate = (task: Case): void => {
    dispatch({ type: 'tasks/updateTask', payload: task });
  };

//Пример
//1  Описываем начальное состояние компонента.выносим состояние на основе которго строиться наш компонент
import Student from './Student';
export default interface StudentsListState {
  students: Student[];}

//2 Задаем тип actiona.Описываем действия которые может совершить пользователь и те данные которые необходимы для действий
import Student, { StudentId } from './Student';
type Action =
  | { type: 'students/loadStudents'; payload: Student[] } //наименование раздела/само действие которое мы совершаем
  | { type: 'students/deleteStudent'; payload: StudentId } //полезная нагрузка(некий данные необходимые для совершения данного действия)
  | { type: 'students/updateStudent'; payload: Student }
  | { type: 'students/createStudent'; payload: Student };
export default Action;

///3 Создаем функцию редьюсер

import Action from './types/Actions';
import Action from './types/Actions';
import StudentsListState from './types/StudentsListState';
//reducer это функция которая принимает старое состояние компонента и action и возвращает новое состоние компонента на основе этого actioana. Редбюсер показывает как у нас меняетсья состояние когда происходит какой-то action. Reducer обязательно чиста функция,(1.Идемпоте́нтность-при одних и тех же архументах выдает один и  тот же результта. 2.side-эффект:любые изменения в не этой функции. 3. не мутирует аргументы   ). Так как работа реакта основана на работе с немутирующими данными, поэтому мы импользуем reduce как чистую функцию, чтобы при обновлении состояния у нас меняалсь ссылка на объект, и тогда под копотом у реакта будет происходить сравнениеие старого состояния и нового , произойдет рендеринг компонента так у новго состояния уже будет новая ссылка. Это именно та причина по которой мы в reducer не можем кинуть и fetch и reducer не может быть асинхронным

export default function reducer(
  state: StudentsListState,
  action: Action,
): StudentsListState {
  switch (action.type) {
    case 'students/loadStudents': {
      return {
        ...state,
        students: action.payload,
      };
    }
    case 'students/deleteStudent': {
      return {
        ...state,
        students: state.students.filter(
          (s) => s.id !== action.payload,
        ),
      };
    }
    case 'students/createStudent': {
      return {
        ...state,
        students: [...state.students, action.payload],
      };
    }
    case 'students/updateStudent': {
      return {
        ...state,
        students: state.students.map((x) =>
          x.id === action.payload.id ? action.payload : x,
        ),
      };
    }
  }
}

// 4 добавляем dispatch(говорим что эти действия произошли) в основной код

import { useEffect, useState } from 'react';
import * as api from './api'; //все методы положили в объект api и их можн овызвать через точку
import Student from './types/Student';
import './StudentsList.css';
import StudentsRow from './StudentRow';
import reducer from './reducer';
import StudentsListState from './types/StudentsListState';

const initialState: StudentsListState = { students: [] };

export default function StudentsList(): JSX.Element {
  //   const [arrStudents, setArrStudents] = useState<Student[]>([]);
  const [state, dispatch] = useReducer(reducer, initialState);
  const { students } = state;
  const [name, setName] = useState('');
  const [age, setAge] = useState('');
  console.log(name, age);

  //READ
  useEffect(() => {
    api
      .loadStudents()
      .then((data) =>
        dispatch({ type: 'students/loadStudents', payload: data }),
      );
  }, []);

  //DELETE
  function handleRemove(studentToRemove: Student): void {
    //  setArrStudents(arrStudents.filter((s) => s !== studentToRemove)); //в сеттер передаем новое значение, не через функцию если мы не используем старое значение;
    setArrStudents((students) =>
      dispatch({
        type: 'students/deleteStudent',
        payload: studentToRemove.id,
      }),
    ); //в сеттер передаем функцию, если новое значение основанное на старом;
  }

  //CREATE
  //для мышки -React.MouseEvent, для формы - React.FormEvent, для input - ReactChangeEvent , для кнопки- React.MouseEvent
  function handleSubmit(event: React.FormEvent): void {
    event.preventDefault();

    const student: Student = {
      id: students.length + 1,
      name,
      age: Number(age),
    };

    dispatch({ type: 'students/createStudent', payload: student });
  }

  //UPDATE
  const handleUpdate = (newStudent: Student): void => {

    dispatch({ type: 'students/updateStudent', payload: newStudent });
  };
  return (
    <div className="students-list-container">
      <form onSubmit={handleSubmit} action="#">
        <input
          placeholder="Student name"
          value={name}
          onChange={(event) => setName(event.target.value)}
        />{' '}
        <input
          type="number"
          placeholder="age
		  "
          value={age}
          onChange={(event) => setAge(event.target.value)}
        />{' '}
        <button type="submit">OK</button>
      </form>
      <ul>
        {students.map((student) => (
          <StudentsRow
            key={student.id}
            student={student}
            onRemove={handleRemove}
            onUpdate={handleUpdate}
          />
        ))}
      </ul>
    </div>
  );
}
```

# Lesson 313 React Router(Link,Outlet,useNavigate, useParams)=========================

- npm i react-router-dom-устанавливаем пакет для роутеров (npm i react-router-dom @types/react-router-dom)
- import { BrowserRouter } from 'react-router-dom';-для того чтобы работала библиотека router
  <BrowserRouter>
  <App />
  </BrowserRouter>

```javascript
// Добавляем роутеры на компоненты в файле где находяться все компоненты
  return (
      <Routes>
        <Route path="/" element={<Main />}>
          <Route path="/students" element={<StudentsList />} />
          <Route path="/counter" element={<Counter />} />
			 // если endpoint указали не верно переводит на указанную стр.
			  <Route path="*" element={<Counter />} />
        </Route>
      </Routes>
    );

//Добавляем на главную страницу ссылкы через Link (переход между страницами приложения) для перехода на кампоненты и добавляем Outlet где будут открываться даннеы компоненты
  import { Link, Outlet, useNavigate } from 'react-router-dom';
  <div>
        <Link to="/">Main</Link>&nbsp;&nbsp;&nbsp;
        <Link to="/students">Students list</Link>&nbsp;&nbsp;&nbsp;
        <Link to="/counter">Counter</Link>
      </div>
      <Outlet />

//хук useNavigate для создания нестандартной ссылки для перехода на компонент и для перемещения одной страницу назад(ходит по истории браузера) Переход между страницами приложения
		  const navigate = useNavigate(); //хук useNavigate для создания не стандартной ссылки
  const handleBackClick = (): void => {
    //создали функцию обработчик которая перемещает одну страницу назад(ходит по истории браузера)
    navigate(-1);
  };
  const handleMainClick = (): void => {
    //создали функцию обработчик которая переходит по ссылки /
    navigate('/');
  };

//хук useParams для того чтобы доставать данные из URL
import { useParams } from 'react-router-dom';

 const [state, dispatch] = useReducer(reducer, initialState);
  const { students } = state;
const id = Number(useParams().id);//получаем из адресной стрноки передаваемый id <Link to={`/students/${student.id}`}>{student.name}</Link>
  const student = students.find((s) => s.id === id);//ищем по принятому id студента

```

# Lesson 314 React Redux=========================

- Css классы всегда глобальные,независимо в каком компоненте ты их подключил они работают везде
- Добавляем уникальный класс элементу:
  button: "Counter_button\_\_Y7z5b"

```javascript
import style from './Counter.module.css';

<button type="button" className={style.button} onClick={onClick}>
  {children}
</button>;

interface ButtonProps {
  onClick: () => void;
  children: React.ReactNode;
}
```

- React.ReactNode- для типизации внутренности тега <div>React.ReactNode</div>
- Если в проекте есть какие-то общие стили то скорее всего это не стили общие а это компоненты которые можно выделить отдельно в папку src
- Для CSS модулей установить модуль `npm i typescript-plugin-css-modules -D`
- tsconfig.js -это файлик где описаны особенности работы TS на нашем проекте

### useContext:

1.Для того чтобы создать context создаем файл ThemeContext.ts и его тип Theme.ts

```javascript
import { createContext } from 'react';
import Theme from './types/Theme';

const ThemeContext = createContext < Theme > 'blue'; //создаем контекст, указываем его тип и указываем начально его значение

export default ThemeContext; //экспортируем

//Theme.ts
type Theme = 'blue' | 'red';

export default Theme;

```

2.В том компоненте из которго мы хотим передать сверху вниз наше значение мы рендерим компонент, передаем значение value и все остальные компоненты вкладываем внутрь него

```javascript
  <ThemeContext.Provider value={theme}>
<select
            value={theme}
            onChange={(e) => setTheme(e.target.value as Theme)}
          >
            <option value="blue">Blue</option>
            <option value="red">Red</option>
          </select>
  </ThemeContext.Provider>
```

3.В тех файлах в которых мы хотим взять этот контекст мы используем хук useContext куда передаем ThemContext и нам возвращаеться та перемнная которая сверху была передана

```javascript
import { useContext } from 'react';
import ThemeContext from '../../App/ThemeContext';

export default function Articles(): JSX.Element {
  const theme = useContext(ThemeContext);
  return <div style={{ backgroundColor: theme, color: 'white' }}>Article page</div>;
}
```

- Props dreeling (пробуривание пропсов)- это передача пропсов из одного компонета в другой и снова в друго, useContext решает данный момент. Но его не нужно бояться, он более удобочитаемый. useContext лучше использовать, когда необходимо некое состояние использовать во всех компонентах
- Централизованным состоянием называеться state который доступен всему нашему приложении и который из всего нашего приложения может изменяться. Это реализуеться с помощью хуков useReducer и useContext. Данный подход используеться на данный момент во всех приложениях , но в виде Redux.

### Redux

- npm i redux react-redux
- npm i redux-devtools-extension

1. index.tsx-ДОБАВЛЕЯМ ПРОВАЙДЕР И НАШЕ ЦЕНТРАЛИЗОВАННОЕ ХРАНИЛИЩЕ

```javascript
<Provider store={store}>
  //наше централизованное хранилище которое будет пердоваться сверху вниз
  <App />
</Provider>
```

2. Создаем фаил store.ts

```javascript
//Использование Redux без Redux Toolkit -считаеться устаревшей практикой
import { combineReducers, createStore } from 'redux';
// import { composeWithDevTools } from 'redux-devtools-extension';
import counterReducer from './features/counter/сounterReducer';

const store = createStore(
  //создаем харнилище(хранилище нашего централизованного  состояния-(состояние всего проекта)) и передаем весь список редюсеров которые хотим чтобы были в хранилище
  combineReducers({
    counter: counterReducer, //это объект, и в этом объекте мы указали какие разделы у нас есть в нашем централизованном состояние
  }),
  //   composeWithDevTools(),//midlewarka чтобы посмоортеть состояние из редакса
);

export default store;

export type RootState = ReturnType<typeof store.getState>; //берем тип централизованного состояния(типизируем централизованное состояние)
```

3. Заменяем useReducer на useDispatch достаем от туда наш dispatch если он нам нужны передовать какие-то action и на useSelector если нам нужно достать из нашего централизованного состояния

```javascript
const dispatch = useDispatch(); //получаем функцию dispatch ? а дтспатч нужен для изменения state
const state = useSelector((globalState: RootState) => globalState.counter); // для доступа к центразлизованному состоянию
```

4. В функцию reducer добавляем аргументы в виде состояния

```javascript
export default function counterReducer(
  state: CounterState = initialState,
  action: Action)


   //возвращаем state если action из другого раздела

  return state
```

### lesson 321 Redux Toolkit================

# Архитектура Flux

- `Store(useSelector)->React-компонент(Пользоват.действия)->Fetch(берем данные)->dispatch(Action)->reducer->Store` -однонаправленный поток данных (все взаимодействия идут в одну сторону)

- boilerplate code -шаблонный код, который требуеться писать програмисту каждый раз. Copilot-пишет за тебя boilerplate cod. Также boilerplate cod стараються убрать под капот во фреймворки. Redux Toolkit данный пример

- npm i @reduxjs/toolkit

# Redux toolkit

```javascript
Необходимо установить пакеты

npm i redux react-redux
npm i @reduxjs/toolkit

1. Создаем тип централизованного состояния и тип его аргумента

CounterState.ts
import Color from './Сolor';

interface CounterState {
  value: number;
  color: Color;
}
export default CounterState;


Color.ts
type Color = 'red' | 'green' | 'blue';
export default Color;

2. Создаем slice -это замена actionCreators, actionType, reducer. Создаем состояние по умолчанию initialState

// slice заменяет все эти файлы=ActionType + actionCreators + reducer

import {
  PayloadAction,
  createAsyncThunk,
  createSlice,
} from '@reduxjs/toolkit';
import CounterState from './types/сounterState';
import Color from './types/Сolor';
import * as api from './api';

export const initialState: CounterState = { value: 0, color: 'blue' };

//асинхронный action  creator (санки)
// в createAsyncThunk мы кидаем fetch, после этого мы можем вернуть его или другое значение return и она уйдет в action.type в extraReducer где мы с помощью него можем поменять централизованное состояние
export const changeColor = createAsyncThunk(//это функция называеться actionCreator-это функция которая возвращает нам action, потом мы эту функцию вызываем в dispatch. После вызова dispatcha у нас вызваеться callbak внизу, а после него запуститься extraReducer
  'counter/changeColor',//создаем action
  async (color: Color) => {
    await api.changeColor(color); //кидаем фетч и возвращаем некие данные , в данном случае для изменения state нам нужен цвет
    //этот результат уйдет в редьюсер
    return color;
  },
); //здесь пишем название action которое будет сгененрировано когда этот fetch будет направлен

//этот thunk просто отправляет даннеы на сервер и все
export const saveCounterValue = createAsyncThunk(
  'counter/saveValue',
  async (value: number) => {
    api.save(value);
    // возвращаем те данные которые нужны, чтобы поменять state
   //  return value; // если в state ничего менять не нужно то мы ничего не возвращаем и в не пишем extraReducer
  },
);

const counterSlice = createSlice({
  name: 'counter', // название Slice
  initialState, // состояние с которым мы работаем
  reducers: {
    // actionCreators(функция slice создает их автоматически  по reduceram), actionType(a actionCreator создают автоматически actioType), reducer (описываем reducer )
    minus(state, action: PayloadAction<number>) {
      //можно мутировать state, мы уже работаем с копией state
      state.value -= action.payload;
    },
    plus(state, action: PayloadAction<number>) {
      state.value += action.payload;
    },
   //  changeColor(state, action: PayloadAction<Color>) {//заменили на extraReducer
   //    state.color = action.payload;
   //  },
  },
    //для редьюсеров которые кидают fetch
  extraReducers: (builder) => {
    builder
      .addCase(
        changeColor.fulfilled, // когда fetch от changeColor завершиться вызови эту функцию которая по сути являеться редьюсером
        (state, action) => {
          //в action payload приходит результат из thunk
          const color = action.payload;
          state.color = color;
        },
      )
      // .addCase(saveCounterValue.fulfilled, (state, action) => {
      //   state.value = action.payload;
      // });
  },
});

//экспортируем креайторы
export const { minus, plus, changeColor } = counterSlice.actions;

// экспортируем редьюсер
export default counterSlice.reducer;



3. Создаем store, куда помещаем наши reducer и типизируем центразилованное состояние с dispatчом. В index нужно поместить наш store (чем в выше компонент мы передаемт тем лучше)

index.tsx
<Provider store={store}>//наше централизованное хранилище которое будет передоваться сверху вниз. Связываем наш store со всеми компонентами
      <App />
    </Provider>

slice.ts
//Использование Redux без Redux Toolkit -считаеться устаревшей практикой
import { configureStore } from '@reduxjs/toolkit';
import { useDispatch } from 'react-redux';
import counterReducer from './features/counter/counterSlice';
import authReducer from './features/auth/authSlice';

const store = configureStore(
  //создаем харнилище(хранилище нашего централизованного ()состояние всего проекта) состояния) и передаем весь список редюсеров которые хотим чтобы были в хранилище
  {
    reducer: { counter: counterReducer, auth: authReducer },//перед редьюсервами указываем название папок(разделов) где они находяться
  },
);

export type RootState = ReturnType<typeof store.getState>; //берем тип централизованного состояния(типизируем централизованное состояние)

//Для правильной типизации будем использовать useAppDispatch вместо useDispatch
export type AppDispatch = typeof store.dispatch;
export const useAppDispatch: () => AppDispatch = useDispatch;

export default store;

3. Создаем selector.ts чтобы достать необходимые данные с помощью useSelectora из централизованного состояния.

import { RootState } from '../../store';

//селектор всегда ничнаються со слова select
export const selectCounterValue = (state: RootState): number =>
  state.counter.value; //counter -это раздел(папка) указываеться в store, а value это поле которое мы берем из типизация состояния нашего компонента
export const selectColor = (state: RootState): string =>
  state.counter.color; //counter -это раздел, а value это поле


4. Используем creator и reducer в dispatch и selector в  useSelector в компоненте

import { plus, minus, changeColor } from './counterSlice';
import { useAppDispatch } from '../../store';

function handleClickCountPlus(): void {
    dispatch(plus(1));
  }

  const dispatch = useAppDispatch();
  const value = useSelector(selectCounterValue);
  const save = (): void => {
    dispatch(saveCounterValue(value))
      //  api.save(value)
      .then(() => {
        console.log('react saved');
      });
  };
  const login = useSelector(selectLogin);
  const curColor = useSelector(selectColor);


```

# lesson 322 RTK ====================================

### extraReducer

1.в createAsyncThunk мы кидаем fetch, после этого мы можем вернуть его или другое значение return и она уйдет в action.type в extraReducer где мы с помощью него можем поменять централизованное состояние

```javascript
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import StudentsListState from './types/StudentsListState';
import * as api from './api';
import Student, { StudentId } from './types/Student';

const initialState: StudentsListState = { students: [] };

export const loadStudents = createAsyncThunk(
  //это функция которая возвращает нам action, потом мы эту функцию вызываем в dispatch
  'students/loadStudents',
  () => api.loadStudents(),
  //в callback указываем аргумент который нам нужно передать через fetch? если нам ничего передат myt нужно то и при вызове loadStudents в dispatche тоже ничего укзыват myt нужно
);

export const deleteStudent = createAsyncThunk('students/deleteStudent', async (id: StudentId) => {
  await api.removeStudent(id);
  return id;
});

export const createStudent = createAsyncThunk(
  'students/createStudent',
  async (student: { name: string, age: number }) => {
    const newStudent = await api.createStudent(student);
    return newStudent;
  },
);

export const updateStudent = createAsyncThunk(
  'students/updateStudent',
  async (student: Student) => {
    await api.updateStudent(student);
    return student;
  },
);

const studentsSlice = createSlice({
  name: 'students',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(loadStudents.fulfilled, (state, action) => {
        state.students = action.payload;
      })
      .addCase(deleteStudent.fulfilled, (state, action) => {
        state.students = state.students.filter((s) => {
          s.id !== action.payload;
        });
      })
      .addCase(createStudent.fulfilled, (state, action) => {
        state.students.push(action.payload);
      })
      .addCase(updateStudent.fulfilled, (state, action) => {
        state.students = state.students.map((s) => {
          if (s.id === action.payload.id) {
            return action.payload;
          }
          return s;
        });
      });
  },
});
```

# lesson memo, useMemo, useCallback

Три правила оптимизации реакт приложения:

1. Функции которые передаються в props заворачивать в useCallback
2. Большие компоненты (где есть state, context, props) export через React.memo
3. Операции дорогие оборачиваем в useMemo (типа sort)

- если мы меняем какое состояние то перерендариваеться компонент и его дочерние компоненты, при этом происходит перерендорование не дом дерева (оно не меняеться), а перерендываеться виртуально дерево дом в реакте(каждый раз при изменения state запускаються функции которые к нему относяться) (смотрит какие его части изменилоись и точечно вносить изменения в дерево дом), если перередывалось все дерево дом то сайт бы жутку лагал. Для борьбы с ним использует high order components -компонент высшего порядка это функция которая оборачивает реакт компонент и возвращает другой реакт компонент (React.memo). Берем большие наши компоненты и при этом у них есть state, props или context( случие в которых они изменяються). В этом случае используем React.memo(). Если мы не совсем понимаем стоит ли оборачивать в useMemo ,лучше обернуть хуже сильно не станет а лучше в полне может

```javascript
//убераме export у компонента и в самом внизу прописываеь  React.memo()
export default function Counter(): JSX.Element {

	export default React.memo(Counter)
```

- если мы передаем функцию в качестве пропса то ее нужно обернуть в хук useCallback, чтобы при обновлении родителя с этой фукцией дочерний компонент не перерендоривался, так как при обновлении родительского компонента будут зановов создоваться функции в нем и для дочернего компонента это уже будут новые функции которые передаеються через props(соответсвенно props обновиться). useCallback это тот же useMemo но только для функций.
- useCallback (возвращает мемоизиролваный callback в const) работает по такому принципу,функция которую мы оборачиваем в него при рендере всего компонента создаеться, а после когда запускаеться компонент он видит что массив зависимостей не поменялся и в const уже попадает не новая функция а старая ,которая была создана изначально. При передачи функции в пропс всегда ее нужно оборачивать в useCallback.

```javascript
// CREATE
// для мышки -React.MouseEvent, для формы - React.FormEvent,
// для input - ReactChangeEvent , для кнопки- React.MouseEvent
const handleSubmit = useCallback(
  (event: React.FormEvent): void => {
    event.preventDefault();
    dispatch(createStudent({ name, age: Number(age) }));
  },
  [dispatch, name, age], //передаем массив зависимостей как и в случае с useEffect, происходит зымкание с name и age
);
```

- замыкание это когда есть функция и в нее попадает внешние переменные , обьявленые не в самой функции, а обьявлены в верхних областях видимости
- const students = [...useSelector(studentsSelector)].sort((a,b)=>a.name.localeCompare(b.name));//сортировка по имени

- useMemo -первы раз кошда компонент отрендариться мы получис массив студентов и отсортируем его по алфавиту,последующие разы когда будет рендеринг компонента если массив зависимотей не изменился то он callback в useMemo не будет даже запускать ,а будет использвать списко отсортированный в первый раз

useMemo — это хук, который возвращает мемоизированное значение. Это означает, что значение будет вычислено только один раз и будет повторно использоваться в последующих рендерах, если его зависимости не изменились. Это полезно для оптимизации вычислений, которые могут быть дорогостоящими.

```javascript
const originalStudents = useSelector(studentsSelector);
const students = useMemo(
  () => [...originalStudents].sort((a, b) => a.name.localeCompare(b.name)), //сортировка по имени
  [originalStudents],
);
```

# Деление проектов на релизы

Суть выкатывать на каждом релизе некий готовый сайт, просто упрощенный и далее усложнять. С самого начала мы уже получаем некий готовый продукт и можем корректировать его.

Планирование:

- Распределяем роли пользователей (админ, юзер)
- Мокапы-рисунки страниц нашего сайт (примерные). Определяемся с сущностями.
- Начальный дизайн (примерный стиль, для эмоциональной состовляющей разработки проекта)

Релиз 1 (прототип) Альфа версия (делаем простенький сайт но чтобы он уже работал):

- БД (необходимые для этого релиза таблицы)
- Создать некую главную страницу

Релиз 2 (добавить простую логику)

- Фейковая оплата
- Заказа улетает на почту (без сложной админки)

Релиз 3 (усложняем предыдущие моменты)

- начинаем решать юредические вопросы по оплате
- статус заказа

### Key в реакте

Key -Ключи нужны для того чтобы React смог отличить элементы при изменении их, для быстро действия (иногда если не передать ключи поведение дом элементов будет не предсказуемым, могут появляться баги, слетать скролы). Ключи нужны если массив динамичный (удаляем, добавляем ...), но лучше все равно их всегда проставлять и заренее закладывать возможное улучшение сегодня надо статичный завтра динамичный(устойчивость к ошибкам).

```javascript
{students.map((student, index) => (
          <StudentsRow
            key={student.id}
            student={student}
            onRemove={handleRemove}
            onUpdate={handleUpdate}
            className={(style as any)[`student-row-${index}`]}
          />
        ))}

```

### Обрабатываем ошибки в RTK

```javascript
ФАИЛ на сервере
res.status(401).json({error:'Такого пользователя нет либо пароли не совпадают'})

ФАИЛ api.js
export async function login(credentials: Credentials): Promise<void> {
  await fetch('/api/auth/login', {
    method: 'POST',
    body: JSON.stringify(credentials),
    headers: { 'Content-Type': 'application/json' },
  });

// реджектим промис если вернулся ошибочный статус. Если пришла ошибка то мы достаем ошибку из ответа и бросаем текст ошибки
  if (res.status >= 400) {
    const error = await res.
	 json();
    throw new Error(error);
  }
}

ФАИЛ slice.js
//в санки вернули этот промис
  export const login = createAsyncThunk(
    'auth/login',
    async (credentials: Credentials) => {
      if (!credentials.name.trim() || !credentials.password.trim()) {//бросаем ошибку валидации, если что-то не нравиться во входных данных
        throw new Error('Не все поля заполнены');
      }
      {
        return api.login(credentials);
      }
    },
  );

  const authSlice = createSlice({
	 name: 'auth',
	 initialState: {
		loginFormError: undefined,
	 },
	 reducers: {
		// редьюсер для очистки ошибки
		resetLoginFormError: (state) => {
		  state.loginFormError = undefined;
		}, resetRegistrationFormError: (state) => {
		  state.registrationFormError = undefined;
		}
	 },


// так изменяеться state если вернулась ошибка
  extraReducers: (builder) => {
    builder
      .addCase(login.rejected, (state, action) => {
      state.loginFormError=action.error.message //появляеться ation.error и у него есть message и кладем его в state
      })}
		// если логин и пароль зарезолвился успешно переходим на главную страницу
		.addCades(login.fulfilled, (state, action) => {
		  state.loginFormError=undefined
		})})

ФАИЛ selector.ts
export const selectLoginFormError=(state:RootState):string|undefined=>state.auth.loginFormError

ФАИЛ Login.tsx
//В компоненте
		const error = useSelector(selectLoginFormError);

  const handleSubmit = React.useCallback(
    async (event: React.FormEvent) => {
      event.preventDefault();

      //делаем диспатч санка
      const dispatchResult = await dispatch(
        login({ name, password }),
      );

// данной конструкцие проверяем что данный thunk зарезолвился успешно. Если вернулся ошибочный статус. Если пришла ошибка то мы достаем ошибку из ответа и бросаем текст ошибки. Если все хорошо то переходим на главную страницу.
      if (login.fulfilled.match(dispatchResult)) {//проверяем что санк login зарезолвился успешно
        navigate('/');
      };
		if (login.rejected.match(dispatchResult)) { //проверяем если с сервера у нас пришла ошмибка то выводим ее в консоль
	  console.error(dispatchResult.error.message)}
    },[dispatch,navigate,password,name]

  );

// очищаем ошибки если меняем поля логин и пароль
const handleNameChange = React.useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
  setName(event.target.value);
  dispatch (resetLoginFormError())
},[dispatch];)

const handlePasswordChange = React.useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
  setPassword(event.target.value);
  dispatch (resetLoginFormError())
},[dispatch]);


// если есть ошибка выводим ее
  return{
	{error&&(<div className="invalid-feedback mb-3" style={{display:'block'}}>{error}</div>)}
  }
  //меняем цвет если есть ошибка
<input type="text" className={'form-control ${error ? "is-invalid" : ""}'}
id='name-input'
name='username'
value={name}
onChange={handleNameChange}
/>
```

- хук useForm -

### Замыкание

- Лексическое окружение - это некоторый скрытый объект который есть у любого блока, скрипта или функции в JS. Данный объект состоит из двух частей 1. объект с переменными в текущей области видимости.2 ссылка на родителеское -внешнее лексическое окружение. Лексическое окружении локальное которое создаеться в функции , создаеться только тогда когда эту функцию вызывают.
- Замыкание- это способность функции в JS запоминать лексическое окружение, в котором она была создана (т.е хранить в себе ссылку на это окружение).

```javascript
function makeAdder(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2)); //  7
console.log(add10(2)); //  12
```

### Функции декораторы

- Функции-декораторы в программировании — это специальные функции, которые модифицируют или расширяют поведение других функций или классов.

### Немедленно вызываемая функция

- (function () {...})(); — это немедленно вызываемая функция. Она выполняется сразу же после определения.

### Map

```javascript
Создание и инициализация Map
new Map(): Создает новый объект Map.
new Map(iterable): Создает новый объект Map и инициализирует его элементами из итерируемого объекта (например, массива).

Добавление и удаление элементов
map.set(key, value): Добавляет новую пару ключ-значение в Map. Если ключ уже существует, его значение будет обновлено.
map.delete(key): Удаляет пару ключ-значение по ключу. Возвращает true, если элемент был успешно удален, и false в противном случае.
map.clear(): Удаляет все пары ключ-значение из Map.

Поиск и проверка наличия элементов
map.has(key): Проверяет, существует ли в Map пара с указанным ключом. Возвращает true или false.
map.get(key): Возвращает значение, соответствующее ключу. Если ключ не найден, возвращает undefined.

Итерация по элементам
map.keys(): Возвращает новый итератор, который перебирает ключи Map.
map.values(): Возвращает новый итератор, который перебирает значения Map.
map.entries(): Возвращает новый итератор, который перебирает пары ключ-значение Map.
map.forEach(callback[, thisArg]): Выполняет указанную функцию для каждого элемента Map.

Размер и проверка на пустоту
map.size: Возвращает количество элементов в Map.
map.empty: Возвращает true, если Map не содержит элементов, и false в противном случае.

```

### Управляемый компонент в Reacte (двухстороннене связывание)

```javascript
const [title, setTitle] = useState('');

<MyInput
  type="text"
  placeholder="Название поста"
  value={title}
  onChange={(e) => setTitle(e.target.value)}
/>;

const MyInput = (props) => {
  return <input className={classes.myInput} {...props} />;
};
```

### Неуправляемый компонент в Reacte

```javascript
const bodyInputRef = useRef(''); //создаем ссылку ref

<MyInput type="text" placeholder="Описание поста" ref={bodyInputRef} />; //добавляем ее на наш компонент

import React from 'react';
import classes from './MyInput.module.css';
const MyInput = React.forwardRef((props, ref) => {
  //оборачиваем наш компонент в React.forwardRef, чтобы реакт понял куда передавать ref и вешаем его на input
  return <input ref={ref} className={classes.myInput} {...props} />;
});

export default MyInput;
```

### когда нужно изменить состояние родителя из дочернего компонента

```javascript
const createPost = (newPost) => {
  //(callback с передаваемами данными из дочернего компонента)
  setPosts((posts) => [...posts, newPost]);
};

return (
  <div className="App">
    <PostForm create={createPost} />
    <PostList posts={posts} title="Посты про JS " />
  </div>
);
```

### Cортировка

```javascript
const [selectedSort, setSelectedSort] = useState('');

const sortPosts = (sort) => {
  setSelectedSort(sort);
  setPosts([...posts].sort((a, b) => a[sort].localeCompare(b[sort])));
};

<MySelect
  value={selectedSort}
  onChange={sortPosts}
  defaultValue="Сортировка"
  options={[
    { value: 'title', name: 'По названию' },
    { value: 'body', name: 'По описанию ' },
  ]}
/>;

const MySelect = ({ options, defaultValue, value, onChange }) => {
  return (
    <select value={value} onChange={(event) => onChange(event.target.value)}>
      <option disabled value="value1">
        {defaultValue}
      </option>
      {options.map((option) => (
        <option key={option.value} value={option.value}>
          {option.name}
        </option>
      ))}
    </select>
  );
};
```

### Модальное окно

```javascript
const [modal, setModal] = useState(false);

<MyModal visible={modal} setVisible={setModal}>
  <PostForm create={createPost} />
</MyModal>;

import React from 'react';
import cl from './MyModal.module.css';

const MyModal = ({ children, visible, setVisible }) => {
  const rootClasses = [cl.myModal];
  if (visible) {
    rootClasses.push(cl.active);
  }

  return (
    <div className={rootClasses.join(' ')} onClick={() => setVisible(false)}>
      {/* добавляем несколько классов */}
      <div className={cl.myModalContent} onClick={(e) => e.stopPropagation()}>
        {children}
      </div>
    </div>
  );
};

export default MyModal;
```

### Анимирование эффекты

- npm install react-transition-group --save -библиотека для анимирования списком , отслеживать фазы анимации

```javascript
import React from 'react';
import PostItem from './PostItem';
import { CSSTransition, TransitionGroup } from 'react-transition-group';//подкл. библ

const PostList = ({ posts, title, remove }) => {
  if (!posts.length) {
    return <h1 style={{ textAlign: 'center' }}>Посты не найдены!</h1>;
  }

  return (
    <div>
      <h1 style={{ textAlign: 'center' }}>{title}</h1>
		{/* добавл. анимацию на вывод списка*/}
      <TransitionGroup>//вешаем на список
        {posts.map((post, index) => (
          <CSSTransition key={post.id} timeout={500} classNames="post">//вешаем на корень
            <PostItem remove={remove} number={index + 1} post={post} />
          </CSSTransition>
        ))}
      </TransitionGroup>
    </div>
  );
};

export default PostList;


App.css

//добавляем классы
.post-enter {
  transform: translateX(-350px);
}
.post-enter-active {
  transform: translateX(0px);
  transition: all 500ms ease-in;
}
.post-exit {
  opacity: 1;
}
.post-exit-active {
  transform: translateX(-350px);
  transition: all 500ms ease-in;
}
```

### Запросы через axios

- npm i axios установка библиотеки

```javascript
import axios from 'axios';

async function fetchPosts() {
  const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
  setPosts(response.data);
}
```

### Pagination страницы

```javascript
// кол. стр.
const [totalPages, setTotalPages] = useState(0);
// фун. смен. стр.
const changePage = (page) => {
  setPage(page);
};

<Pagination page={page} changePage={changePage} totalPages={totalPages} />;

// Pagination.jsx
import React from 'react';
import { getPagesArray } from '../../../utils/pages';

// в пропсах кол.стр, выб.стр., фун.изм.выб.стр
const Pagination = ({ totalPages, page, changePage }) => {
  // массив страниц
  let pagesArray = getPagesArray(totalPages);

  return (
    <div className="page__wrapper">
      {/* выводим страницы */}
      {pagesArray.map((p) => (
        <span
          //   смена стр.
          onClick={() => changePage(p)}
          //  ключем выбираем стр. так как она уникальна
          key={p}
          //  невеш.класс выд.выб. стр.
          className={page === p ? 'page page__current' : 'page'}
        >
          {p}
        </span>
      ))}
    </div>
  );
};

export default Pagination;
```

### Переход по страницам

```javascript
App.js
  <BrowserRouter>
      <Navbar />
      <AppRouter />
    </BrowserRouter>

AppRouter.jsx
<Routes>
  <Route path="/about" element={<About />} />
  <Route exact path="/posts" element={<Posts />} />
  <Route exact path="/posts/:id" element={<PostldPage />} />
  <Route path="/*" element={<Navigate to="/posts" replace />} /> //при вводе иного
  Url перевод на роутер /posts
</Routes>
```

### Бесконечный скролл

```javascript
useEffect(() => {
  if (isPostLoading) return;
  if (observer.current) observer.current.disconnect();
  let callback = function (entries, observer) {
    // entries массив эл. за кот. мы наблюд.
    if (entries[0].isIntersecting && page < totalPages) {
      // isIntersecting-элем в зон.вид. или нет bulien
      // когда доходим до набл. div прибавл. стр. на 1 и у нас подгружаються новые данные
      setPage(page + 1);
    }
  };
  observer.current = new IntersectionObserver(callback);
  observer.current.observe(lastElement.current);
}, [isPostLoading]);

<div>
  ref={lastElement}
  style={{ height: '20px', background: 'red' }}>
</div>;
```

### JWT токены

- npm i @reduxjs/toolkit react-redux redux-logger @types/redux-logger

### Mobx

npm i mobx mobx-react-lite

# Задачи в JS

_Нахождение в массиве чисел max/min_

```javascript
const array = [100,10, 2, 3, 4, 5, 6, 6];

1) let max = array[0];
array.forEach((element) => {element > max ? (max = element) : max;});

2)let newMax = array.reduce((acc, el) => Math.max(acc, el));

3)let massiv = array.sort((x1, x2) => x1 - x2);
console.log(massiv[massiv.length - 1]);
```

_Сортировка массива объекта_
по числам в объектах:

```javascript
let array = [
  { name: 'Saidar', age: 10 },
  { name: 'Oleg', age: 5 },
];

let newSort = array.sort((a1, a2) => a1.age - a2.age);
```

по строкам в объектах:

```javascript
let newSortText = array.sort((a1, a2) => a1.name.localeCompare(a2.name));
```

_Развернуть массив элементов:_

```javascript
const array = [100,10, 2, 3, 4, 5, 6, 6];

1)array.reverse();

2)const reversed = [];
for (let i = array.length - 1; i >= 0; i--) {reversed.push(array[i]);}

3)const reversArray = array.map((e, i, arr) => arr[arr.length - i - 1]);

4)console.log([...array].map(array.pop, array))
```

_Отфильтровать falsy знаения в массиве_

```javascript
const array = [7, 'correct', 0, false, 9, NaN, ''];

1)let notFalsy = [];
for (let i = 0; i < array.length; i++) {
  if (!!array[i]) {notFalsy.push(array[i]);}
}

2)let newArray = array.filter((e) => !!e );

3)let newArray = array.filter(Boolean);
```

_Найти дубликаты (повторяющиеся элементы) в массиве_

```javascript
const array = [1, 1, 3, 4, 3, 5, 6, 5];

const newArray = array
  .sort((x1, x2) => x1 - x2)
  .reduce((acc, next, index, arr) => (next === arr[index + 1] ? [...acc, next] : acc), []);
```

### Real time взаимодействие WebSocket

-npx create-react-app .

- npm i express cors ws nodemon
- npm i axios

### RTK query

1. Создаем postServise.ts -создаем там наши сервисы , прописываем наши API (эндпоинты), на которые в дальнейшем будет отправлять запросы и как-то изменять наше состояние.
   Создаем их с помощью build.mutation(DELTET, PUT, PUTCH) или build.query (GET)

```javascript
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { IPost } from '../models/IPost';

export const postAPI = createApi({
  reducerPath: 'postAPI', //некий уникальный ключ который определяет текущий сервис
  baseQuery: fetchBaseQuery({
    baseUrl: 'http://localhost:8000',// базовый адрес
  }),
  tagTypes: ['Post'], // проставляем доп.теги чтобы Redux знал куда нам нужно созданый элемент добавить
  endpoints: (build) => ({
    fetchAllPosts: build.query<IPost[], number>({
      // здесь описываем все наши эндпоинты, на которые будем отправлять запросы и как-то изменять наше состояние
      // endpoints это функция которая возвращает некоторый объект
      // в объекты в виде ключа указываем название метода с помощью которого будет получать и возращать некоторые данные, а в значение мы передаем
      // результат  вызова mutation(предназн. для изменения данных post Put запросы) или query(предназанчен для получения данных с сервера Get)
      query: (limit: number = 5) => ({
        // указываем лимит и сервер нам будет возвращать лишь 5 элем. в массиве
        url: `/posts`,
        params: { _limit: limit }, // указываем сам query параметр который будет уходить на сервер
      }),
      providesTags: (result) => ['Post'], // указываем что вот этот endpoint работает с данным тегом, что он отвечает за доствку данных
    }),
    // создаем еще один endpoint с помощью которого мы создаем пост
    // генериком передаем 1 тип объекта которого мы ожидаем аргментов, 2 тип объекта который нам вернеться
    createPost: build.mutation<IPost, IPost>({
      query: (post) => ({
        url: `/posts`,
        method: 'POST', // поскольку это POST запрос нам явно нужно указать метод
        body: post, // также у пост запроса есть тело в который мы помещаем сам объект, этот объект будет уходить в месте запросос и отправляться на сервер
      }),
      invalidatesTags: ['Post'], // при созданиме поста указываем что эти даннеы становяться не актуальными, соответсвенно RTK query должен эти даннеы заново получить
    }),
    // query это функция которая возвращает объект , сама же она принимает arg которые необходимы для запроса-это может быть тело запроса, какие-то параметры, url
    // здесь мы указываем url для конкртеного endpointa он будет плюсовать к baseUrl

    updatePost: build.mutation<IPost, IPost>({
      query: (post) => ({
        url: `/posts/${post.id}`,
        method: 'PUT',
        body: post,
      }),
      invalidatesTags: ['Post'],
    }),

    deletePost: build.mutation<IPost, IPost>({
      query: (post) => ({
        url: `/posts/${post.id}`,
        method: 'DELETE',
      }),
      invalidatesTags: ['Post'],
    }),
  }),
});


```

2. В компоненте обращаясь к postAPI к нашему сервису мы получаем автосгенерированные хуки на основание endpoint которые описали в service

const {data: posts,error,isLoading,refetch,} = postAPI.useFetchAllPostsQuery(limit //, { pollingInterval: 100000 });

Десруктуризацией достаем методы для работы с сотоянием
первый арг.принимает параметр который как-то будет использщоваться в запрос
// функция refetch, с помощью вызыва ее мы заново подгружаем данные
// реализация лонгпуллинга { pollingInterval: 5000 } указываем время отправки запроса вторым аргументом

```javascript
import React, { useEffect, useState } from 'react';
import { postAPI } from '../services/PostService';
import PostItem from './PostItem';
import { IPost } from '../models/IPost';

const PostContainer = () => {
  const [limit, setLimit] = useState(100);
  const {
    data: posts,
    error,
    isLoading,
    refetch,
  } = postAPI.useFetchAllPostsQuery(
    limit //, { pollingInterval: 100000 }
  ); // получаем автосгенерированные хуки на основание endpoint которые описали в service
  // первый арг.принимает параметр который как-то будет использщоваться в запрос, в данном лсучае ничего нет
  // функция refetch ? с помощью вызыва ее мы заноов подгружаем данные
  // реализация лонгпуллинга  { pollingInterval: 5000 } указываем время отправки запроса вторым аргументом

  const [createPost, { error: createError }] = postAPI.useCreatePostMutation(); // в данном случае мы получаем массив-кортеж, где первый эл.массива функция(которую мы можем вызвать для того чтобы произошла мутация)
  // а второй это объект вк отором находяться поля isLoading? data и т.д.
  //   useEffect(() => {
  //     setTimeout(() => {
  //       setLimit(3);
  //     }, 2000);
  //   },[]); // меняем state с лимтом и у нас вместо 10 объектов приходят 3

  const [deletePost, {}] = postAPI.useDeletePostMutation();
  const [updatePost, {}] = postAPI.useUpdatePostMutation();

  const handleCreate = async () => {
    const title = prompt(); // здесь мы получае название статьи с помощью функции promt (открывающийся инпут)
    await createPost({ title, body: title } as IPost); // так как ID генерирует сервер,чтобы TS не гурался явно указываем тип as IPost
  };

  const handleRemove = (post: IPost) => {
    deletePost(post);
  };
  const handleUpdate = (post: IPost) => {
    updatePost(post);
  };

  return (
    <div>
      <div>
        <button onClick={handleCreate}>Add new post</button>
        {isLoading && <h1>Идет загрузка...</h1>}
        {error && <h1>Произошла ошибка при загрузке</h1>}
        {posts &&
          posts.map((post) => (
            <PostItem
              remove={handleRemove}
              update={handleUpdate}
              key={post.id}
              post={post}
            />
          ))}
      </div>
    </div>
  );
};

export default PostContainer;


PostItem.tsx =============================================
import React, { FC } from 'react';
import { IPost } from '../models/IPost';

interface PostItemProps {
  post: IPost;
  remove: (post: IPost) => void;
  update: (post: IPost) => void;
}

const PostItem: FC<PostItemProps> = ({ post, remove, update }) => {
  const handleRemove = (event: React.MouseEvent) => {
    event.stopPropagation();
    remove(post);
  };
  const handleUpdate = (event: React.MouseEvent) => {
    const title = prompt() || '';
    update({ ...post, title });
  };

  return (
    <div onClick={handleUpdate}>
      {post.id}
      {post.title}
      <button onClick={handleRemove}>Delete</button>
    </div>
  );
};

export default PostItem;
```

### Создаем сервер

- npm install json-server
- Create a db.json file b заполняем содержимым:

```javascript
{
  "posts": [
    { "id": 1, "title": "a title", "views": 100 },
    { "id": 2, "title": "another title", "views": 200 }
  ],
  "comments": [
    { "id": 1, "text": "a comment about post 1", "postId": "1" },
    { "id": 2, "text": "another comment about post 1", "postId": "1" }
  ],
  "profile": {
    "name": "typicode"
  }
}

```

- npx json-server --watch db.json --port 5000 запускаем сервер на 5000 порте

# React Pizza

### Запросы на сервер

```javascript
axios
  .get(
    `https://663282dfc51e14d69564ad25.mockapi.io/pizza?page=${currentPage}&limit=4&${category}${search}&sortBy=${selectedSort.sort}&order=${orderType}`,
  )
  .then((res) => {
    setItems(res.data);
    setIsLoading(false);
  })
  .catch((error) => {
    console.error('Error fetching data:', error);
    setItems(null);
    setIsLoading(false);
  });

fetch(
  `https://663282dfc51e14d69564ad25.mockapi.io/pizza?page=${changePage}&limit=4&${category}${search}&sortBy=${selectedSort.sort}&order=${orderType}`,
)
  .then((response) => {
    return response.json();
  })
  .then((data) => {
    setItems(data);
    setIsLoading(false);
  })
  .catch((error) => {
    console.error('Error fetching data:', error);
  });
```

### debounce в lodash

npm i lodash.debounce

### библиотека для передачи квери параметров в URL

npm i qs

```javascript
// достаем из state параметры и передаем их в строку, если произошел первый рендер и изменились параметры
useEffect(() => {
  if (isMounted) {
    const queryString = qs.stringify({
      sort: selectedSort.sort,
      selectedCategories,
      changePage: currentPage,
    });
    // с помощью navigate передем параметры в адресную строку
    navigate(`?${queryString}`);
  }
  isMounted.current = true; //сообщаем что первый рендер произошел
}, [selectedCategories, selectedSort, currentPage]);

// если был первый рендер то проверяем URL параметры и сохраняем в редакс
useEffect(() => {
  // достаем параметры из адрес. строки (window.location.search) и парсим их в объект (qs.parse) , убираю первый символ (sunstring там ?)
  if (window.location.search) {
    const params = qs.parse(window.location.search.substring(1));
    // из массива list достаем объкты сортировки чтобы потом полностью добавить их в state
    const sort = list.find((obj) => obj.sort === params.sort);
    // и передаем это в редакс
    dispatch(setFilters({ ...params, sort }));
    isSearch.current = true;
  }
}, []);
```

### Убираем элемент(pop up) при нажатие вне его области

```javascript
// Функционал закрытия popUp при нажатие вне его области
useEffect(() => {
  const handleClickOutside = (event) => {
    // Проверяем, является ли event.target дочерним элементом sortRef.current
    if (!event.target.closest('.sort')) {
      setOpen(false);
      console.log(`Click outside`);
    }
  };
  document.body.addEventListener('click', handleClickOutside);
  return () => document.body.removeEventListener('click', handleClickOutside);
}, []);
```

### Хук useLocation

С помощью данного хука мы обращаемся к свойствам адресной строки(также при его использование при хизменнеие адресной строки перерендориваеться компонент):
pathname: Строка, представляющая путь URL.
search: Строка, представляющая строку запроса URL.
hash: Строка, представляющая хеш URL.
state: Объект, содержащий состояние маршрута, переданное при переходе на данный маршрут.

```javascript
const location = useLocation();
const path = location.pathname;
```

### Хук useParams, useSearchParams

useParams с помощью данного хука достаем даннеы из адресной строки /:id
useSearchParams с помощью данного хука достаем даннеы из адресной строки /?sort=rating&selectedCategories=0&changePage=1

```javascript
  <Route path="/pizza/:id" element={<FullPizza />} /> //указываем что в пути будем принимать переменную :id
	  <Link to={`/pizza/${id}`}/> //добавляем ее при переходи по ссылке
const { id } = useParams();// достаем ее в компоненте
  const { data } = await axios.get(`https://663282dfc51e14d69564ad25.mockapi.io/pizza/` + id);// вставляем в запрос
```

### Typescript

```javascript
// Типизация index в корневом элеенте при его доставние из дом дерева as HTMLElement
const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);

// Типизация импорта картинок, создаем отдельный фаил в папке @types называем assets.d.ts и прописываем внутри:
declare module '*.svg' {
  const content: any;
  export default content;
}
declare module '*.png' {
  const content: any;
  export default content;
}

// Типизация useRef его обязательно неоьбходимо типизировать? значения берез наводя на элемент в JSX разметке. В значение передаем null
const ref=useRef<HTMLDivElement>(null)

//Типизация event.target для closest
 if (!(event.target as HTMLElement).closest('.sort')) {
        setOpen(false);
      }

// Типизация пропсов, когда обозначаем что рекат компонент типа FC можем через <CategoriesProps> типизировать пропсы
//Типизация функции передааваемой через пропсы onSelectedCategories
type CategoriesProps = { selectedCategories: number; onSelectedCategories: (id: number) => void };//пропсы это объект со значениями
const Categories: FC<CategoriesProps> = ({ selectedCategories, onSelectedCategories })
//Либо без FС вот так
const Categories = ({ selectedCategories, onSelectedCategories }:CategoriesProps)

// Типизируем с помощью опционлальной цепочки.если есть inputRef.current то вызови метод focus()
  inputRef.current?.focus();
//	либо
	if(inputRef.current){ inputRef.current?.focus();}

//Типизируем state
const [value, setValue] = useState<string>('');

//Игнорирование TS //@ts-ignore
  dispatch(
      //@ts-ignore
      fetchPizza({ currentPage, category, search, selectedSort, orderType }),
    );

//Типизация event, тип берем навадя на input React.ChangeEvent<HTMLInputElement>, ChangeEvent идет типизация event, а <HTMLInputElement> с какого элемента береться.
const handleUpdateSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value);
    changeValueDebounce(e.target.value);
  };
React.MouseEvent<HTMLInputElement>-для клика

//Прикручиваем доп тип к какомуто типу с помощью &
type PopupClick=MouseEvent&{path:Node[]}

(event){
	const _event=event as MouseEvent &PopupClick
}

//Типизируем store, достаем общий state стора store.getState, узнаем его тип typeof, это будет функция и потом с помощью утилити тайп узнаем тип функции ReturnType. Потом эти же RootState типизируем Selector.
export type RootState = ReturnType<typeof store.getState>;

//Типизируем action в slice PayloadAction<ICartItem>
addItem(state, action: PayloadAction<ICartItem>)

//Типизация объекта если у него ключи и значения какого-то одного типа через record Ключ:string, значение:string
params: Record<string, string>

 return data as ICartItem[];

//Можем типизировать createAsyncThunk вот так createAsyncThunk<вовзвращаемое значение, передаваемые аргументы>
export const fetchPizza = createAsyncThunk<ICartItem[], IFetchParams>(
  'pizza/fetchPizzaStatus',
  async (params) => {
    const { currentPage, category, search, selectedSort, orderType } = params;
		// Типизируем что нам вовзаращет axios, типизируем data
    const { data } = await axios.get<ICartItem[]>(
      `https://663282dfc51e14d69564ad25.mockapi.io/pizza?page=${currentPage}&limit=4&${category}${search}&sortBy=${selectedSort.sort}&order=${orderType}`,
    );
    return data;
  },
);

//Используем enum для типизaции, он похож на объект,но его можно использовать при типизации, объект нельзя
//Вместо union type используем enum, вероятность допустить ошибку при вводе уменьшаеться
 status: 'loading' | 'success' | 'error';

export enum Status {
  LOADING = 'loading',
  SUCCESS = 'success',
  ERROR = 'error',
}

//Типизацция диспатча в store, чтобы он понимал какие у нас есть action, и мы могли передовать туда асинхронный action
export type AppDispatch = typeof store.dispatch;// из стора берем все action которые есть и приобразовываем из в типы typeof
export const useAppDispatch = useDispatch.withTypes<AppDispatch>();//потом создаем специальный хук где вывзавем обычный диспатч но уже с типами которые ранее достали

//Типизация UI кнопки
import { ButtonHTMLAttributes } from 'react';

export interface MyButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {}

//Типизация события нажатия на клавишу onKeyDown={handleDownEnter} (e: React.KeyboardEvent<HTMLInputElement>)

const handleDownEnter = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.code === 'Enter') {
      handleAddTask();
    }
  };

	 <input value={value} type="text" onKeyDown={handleDownEnter} />

	  const onKeyDownHandler = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.repeat) return;
    if (e.ctrlKey && e.code === 'Enter') {
      props.addTask(newTaskTitle);
      setNewTaskTitle("");
    }
  };
```

### Оптимизация приложения

```javascript
// useWhyDidUpdate бибилтотека для отслеживания перерисовок
useWhyDidUpdate('Categories', { value, onChangeCategories }); //навзание компонента, пропсы которые в него передаються
```

### Хранение пицц в localStorage

```Javascript
Header.tsx
// В header берем и помешаем массив пицц пришедший с бека в локалстораге
useEffect(() => {
    if (isMounted) {
      const json = JSON.stringify(items);
      localStorage.setItem('cart', json);
    }
  }, [items]);

getCartLs.ts
// потом с помощью данной в функции помещаем в initialState сохраненный массив пицц из локалСторадге ,если он есть
mport { ICartItem } from '../redux/cart/typeSlice';
import { calcTotalPrice } from './calcTotalPrice';

export const getCartLS = () => {
  const data = localStorage.getItem('cart');
  console.log(data);
  const items = data ? JSON.parse(data) : [];
  const totalPrice = calcTotalPrice(items);
  return { items: items as ICartItem[], totalPrice };
};


cartSlice.ts
//Помещаем даннеы из localStorage в initialState
const { items, totalPrice } = getCartLS();
const initialState: TCartSliceState = { totalPrice: totalPrice, items: items };
```

### Разделение bandla code-splitting, оптимизация

```javascript
//Обычный импорт
import { add } from './math';
console.log(add(16, 26));

//Динамический импорт-с помощью него мы наш общий бандл разбиваем на chunki. И тем самым наше приложение подгружает сначала основной bandle , а уже после chunki.Нагрузка уменьшаеться. НА чанки мы можем разбивать любой JS код
import('./math').then((math) => {
  console.log(math.add(16, 26));
});

//React.lazy с router, альтернатива react-loadable библитотека

import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./routes/Home')); //Подгрузка через React.lazy помогает нам подгружать наши компоненты не сразу а только когда они нужны (ренедереться), идети разбитие на chunki и они подгружаються только когда нужны.
const About = lazy(() => import(/*webpackChunkName:"Cart" */ './routes/About')); // добавляем наименованеи chanka

const App = () => (
  <Router>
    <Suspense fallback={<div>Загрузка...</div>}>
      // во время загрузки chunki выходит данный JSX код
      <Routes>
        <Route path="/" element={<Home />} /> // мы подггрузили через React.lazy компоненты и
        сделали под них роутера, то есть при прееходе по данному роутеру как раз будут подгружаться
        chunki
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  </Router>
);

// экспорт компонентов из одного файла, чтобы не было много строчек импорта

index.ts;
export { default as Categories } from './Categories';
export { default as CartItem } from './Categories';
```

# Kama Todo

### Библиотека с уникальными ID

- npm i uuid
- npm i @types/uuid

```javascript
import { v1 } from 'uuid';

{
  id: v1();
}
```

### Делаем так чтобы задачи не создавались с пустыми значениями

```javascript
const handlerAddTask = () => {
  //проверяем что значение в useState не пустое и только тогда имзеняем наш state, с помощью метода .trim() обрезаем справа и слева пробелы
  if (value.trim() !== '') {
    const newTask = { id: tasks[tasks.length - 1].id + 1, title: value, isDone: false };
    dispatch(addTask(newTask));
  }
  setValue('');
};
```

### Вывод ошибки при вводе пустого значения

```javascript
  const [error, setError] = useState<string | null>(null);
	 const handlerDownEnter = (e: React.KeyboardEvent<HTMLInputElement>) => {
    // сбрасываем ошибку при вводе в инпут, чтобы эл. не выделялся
    setError(null);
    if (e.code === 'Enter') {
      handlerAddTask();
    }
  };

  <input
        value={value}
        onChange={handlerChangeInput}
        type="text"
        onKeyDown={handlerDownEnter}
        className={error ? 'error' : ''}
      />
      <button onClick={handlerAddTask}>+</button>
      {error && <div className="error-message">{error}</div>}

```

### Создание переиспользуемого компонента изм.данных

```javascript
TS;
export interface EditableSpanProps {
  title: string;
  onChange: (value: string) => void;
}

<EditableSpan
  title={obj.title}
  onChange={(value) => dispatch(editTask({ listId, taskId: obj.id, title: value }))}
/>;

EditableSpna.jsx;
import { FC, useState } from 'react';
import { EditableSpanProps } from './type';

const EditableSpan: FC<EditableSpanProps> = ({ title, onChange }) => {
  const [editMode, setEditMode] = useState(false);
  return (
    <div>
      {editMode ? (
        <input
          value={title}
          onChange={(e) => onChange(e.target.value)}
          onBlur={() => setEditMode(false)}
          autoFocus
        />
      ) : (
        <span onClick={() => setEditMode(true)}>{title}</span>
      )}
    </div>
  );
};

export default EditableSpan;
```

# Unit test Ulbi TV

### Базовые методы unit тестирования (модульное)

Тесты это ожидание того как должна выполняться функция

- npm i -D jest устанавливаем jest как dev зависимость, в продакшене он нам не нужен, нужен только на этапе разработки

```javascript
// прнцип тестов- Квадрат допустимых значений
-один тест кейс на положительй результат
-corner test, тест кейсы на пограничные значения
-проверяем не валидные значения, больше валидного меньше валидного
// describe -это обертка над всеми тестами если нам нужно запустить несколько сценариев тестов, передаем названия тетс кейса так сказать, каллбек куда засовывем test
// test функция с помощью которой создаем тест, передаем назвние его, а второй каллбек где производим проверки
// expect (ожидание) функция куда передаем результат вычисления тестируемой функции
// .toBe(ожидаемый результат) (быть) метод в который передаем ожидаемый результат
// .toBeLessThan(значение), проверяем что число которые мы получи меньше передаваемого в скобках
// .toBeGreaterThan(), проверяем что число которые мы получи больше передаваемого в скобках
// .not.toBeUndefined(), проверяем что ожидаемое значение не undefined
// .toEqual (к равному) метод проводящий глубокое сравнение(рекурсивное ), для объектов и массивов
// .not.toEqual , с помощоью not мы проверяем что результат не будет равен не правильному результату
// const spyMathPow = jest.spyOn(Math, 'pow'); создаем моковый метод , объект Math c методом pow
// expect(spyMathPow).toBeCalledTimes(1) проверяем количество вызовов метода (один раз)
// При describe есть даннеы методы:
// beforeEach(()=>{ у него есть метод }) функция используеться для проведения каких-то действия до проведения каждого из теста,вызываеться перед каждыйм тестом
// beforeAll(()=>{}), аналогинчо beforeEach но вызывыаеться перед всеми тестами один раз
// afterEach(()=>{jest.clearAllMocks();}), тоже самое что before но после каждого теста
// вызываем у глобального объект jest метод clearAllMocks(), очищаем моковые данные
// afterAll(()=>{}), после всех тестов
// jest.mock('axios'); замоковаем даннеы чтобы при тестирование не шли запросы на стороннние API, а возвращалась заглушка mock
//  axios.get.mockReturnValue(response); возаращаем mock заглушку с помощью данного метода mockReturnValue(response), response переменная куда присвоили моковые данные
// expect(data).toMatchSnapshot() с помощью данного метода создаеться отдельный фаил с фиксацией того что нам возвращает функция, в случае изменения функции будет выдаваться ошибка, после фиксирования новго значения ошибка пропадет

// Пример тестирования валидации (Квдрат допустимых значений)

describe('validateValue', () => {
  test('Корректное значение', () => {
    expect(validateValue(50)).toBe(true);
  });
  test('Меньше корректного значения', () => {
    expect(validateValue(-1)).toBe(false);
  });
  test('Больше корректного значения', () => {
    expect(validateValue(101)).toBe(false);
  });
  test('Пограничное значения снизу', () => {
    expect(validateValue(0)).toBe(true);
  });
  test('Пограничное значения сверху', () => {
    expect(validateValue(100)).toBe(true);
  });
});

//Кейс тестирование преобразования массива в строку с помощью toEqual
describe('mapArrToString', () => {
  test('Корректное значение', () => {
    expect(mapArrToString([1, 2, 3])).toEqual(['1', '2', '3']);
  });
  test('Мешанина', () => {
    expect(mapArrToString([1, 2, 3, null, undefined, 'dasdas'])).toEqual(['1', '2', '3']);
  });
  test('Пустой массив', () => {
    expect(mapArrToString([])).toEqual([]);
  });
  test('Отрицание', () => {
    expect(mapArrToString([1, 2, 3])).not.toEqual([1, 2, 3, 4]);
  });
});


describe('square', () => {
	let mockValue
	beforeEach(()=>{mockValue=Math.random(); // можно допусти добавит в БД
	})
	beforeAll(()=>{})
  test('Корректное значение', () => {
    expect(square(2)).toBe(4);
    expect(square(2)).toBeLessThan(5);
    expect(square(2)).toBeGreaterThan(3);
    expect(square(2)).not.toBeUndefined();// проверяем что ожидаемое значение не равно undefined
  });
	afterEach(()=>{ // можно дупустим удалить из БД
	})
	afterAll(()=>{// можно делать общие очищающие действия
	})
});
```

```javascript
square.js;
const square = (number) => {
  if (number === 1) {
    return number;
  }
  return Math.pow(number, 2);
};
module.export = square;

square.test.js;
const square = require('./square');
description('square', () => {
  test('Корректное значение', () => {
    const spyMathPow = jest.spyOn(Math, 'pow');
    square(2);
    expect(spyMathPow).toBeCalledTimes(1);
  });
  test('Корректное значение', () => {
    const spyMathPow = jest.spyOn(Math, 'pow');
    square(1);
    expect(spyMathPow).toBeCalledTimes(0);
  });
  // в данном случае необходимо очищать моковые данные чтобы тест проходили иначе во втором тесте у нас выдаст ошибку так как в первом тесте функция уже вызывалась
  afterEach(() => {
    jest.clearAllMocks();
  });
});
```

### Тестирование асинхронных функций

- проверка количество вызовов функции
- проверка возвращаемого значения функции

1.

```javascript
const delay = (callback, ms) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(callback());
    }, ms);
  });
};
delay(() => 5 + 5, 1000).then((data) => console.log(data));

module.exports = delay;

const delay = require('./delay');

describe('delay', () => {
  // каллбек делаем асинхронным
  test('Корректное значение', async () => {
    const sum = await delay(() => 3 + 3, 1000);
    expect(sum).tobe(6);
  });
});
```

2.

```javascript
const getData = require('../getdata/getData');
const axios = require('axios');

// замоковаем данные которые нам возвращает мето get у axios, все сторонние модули мы мокаем таким образом
//После вызова jest.mock('axios'), Jest автоматически заменяет все импорты axios в тестах на мок-модуль.
//Поведение мока: По умолчанию, после мокирования модуля, все его экспортируемые функции становятся "мокируемыми",
// то есть они не выполняют никаких действий, кроме возврата значения, которое было задано разработчиком теста.
//Например, можно сделать так, чтобы запрос axios.get() всегда возвращал фиктивный ответ, например, объект с данными о пользователе.
jest.mock('axios');

describe('getData', () => {
  let response;
  // перед каждым тестом задаем моковые данные
  beforeEach(() => {
    response = {
      data: [
        // данные
      ],
    };
  });

  test('Корректное значение', async () => {
    axios.get.mockResolvedValue(response);
    const data = await getData();
    expect(axios.get).toBeCalledTimes(1); //проверяем что axios вызовиться один раз
    expect(data).toEqual(['1', '2', '3']); // проверяем что получим массив
    expect(data).toMatchSnapshot();
  });
});
```

### Тестирование React-library

- проверка наличия элементов на странице
- проверка нажатия на элемент на странице и вывод нового элмента null/ появился
- проверка стилей элемента
- проверка связанного инпута
- проверка асихронного запроса, что при отправки его приходят данные с сервера и отображаются на странице
- проверка перехода между страницами при нажатие на ссылку

```javascript
// render(<App/>) метод для тестирование react компонентов, предеаеться компонет который хотим протестировать, ренедрим его
// let helloWorld=screen.getByText(/hello world/i) получаем элемент с помощью метода screen передовая текст, i-означает игнорирование регистра. Идет поиск по тексту передовая в метод регулярной выражение
//const button = screen.getByRole('button'); поиск по роли (роли можно назначать самим , на div допусти button )
// const input = screen.getByPlaceholderText(/input value.../i);поиск по placeholder
// expect(helloWorld).toBeInTheDocument() проверяем наличие элемента в DOM
// методы screen findBy/All(асинхроннеы), getBy/All(используеться для 100% получение какогото элемента иначе вылезит ошибка), queryBy/All(обычно используеться для уточнения что элемнта нет на странице, не пробрасывает ошибку если не нашел элемент, вовзравает null)
// const helloWorldElem = screen.queryByText(/Hello2/i); expect(helloWorldElem).toBeNull(); проверяем что такого элемента на страницы нет
// screen.debug();-выводит HTML разметку которая сгенерировалась после того как мы отрендеривали компонент
// expect(helloWorldElem).toHaveStyle({ color: 'red' }); проверка что у элемента есть стили
//  expect(screen.queryByTestId('toggle-element')) .toBeInTheDocument(); проверяем наличие элемента на странице, передовая в expect найденный элемент по data-testid="toggle-element", чтобы получать всгда актуальное состояние
// fireEvent.click(btn); с помощью объект fireEvent мы можем вызывать события на элементах (искуственное событие)
//userEvent.type(input, '2'); (воспроизводит полное поведение пользователя , отраб. событие нажатие на клавиши и т.д. )
// expect(screen.getByTestId('div-element')).toContainHTML(''); проверяем что у элемента есть содержимое (изначально пустое )
//fireEvent.change(input, { target: { value: '2' } });  вызываем событие change на input и передаем новое значение
// expect(input).toHaveValue('2'); проверяем соответвие содержимого input
// expect(screen.getByTestId('div-element')).toHaveTextContent('2'); проверяем что у элемента есть содержимое
//<MemoryRouter> для обертки тестированного компонента отвечающего за маршрутизацию

import { fireEvent, render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import App from './App';

describe('TEST APP', () => {
  test('renders learn react/ проверка наличия элемента на странице асинхронная функция', async () => {
    render(<App />);
    // const helloWorldElem = screen.queryByText(/Hello2/i);
    // expect(helloWorldElem).toBeNull();
    screen.debug();
    const helloWorldElem = await screen.findByText(/data/i);
    expect(helloWorldElem).toBeInTheDocument();
    expect(helloWorldElem).toHaveStyle({ color: 'red' });
    screen.debug();
  });

  test('renders learn react link/ проверка наличия элемента на странице', () => {
    render(<App />);
    const helloWorldElem = screen.getByText(/Hello World/i);
    const button = screen.getByRole('button');
    const input = screen.getByPlaceholderText(/input value.../i);
    expect(helloWorldElem).toBeInTheDocument();
    expect(button).toBeInTheDocument();
    expect(input).toBeInTheDocument();
  });

  test('click button/ проверка кнопки', () => {
    render(<App />);
    const btn = screen.getByTestId('toggle-btn');
    expect(screen.queryByTestId('toggle-element')).toBeNull();
    fireEvent.click(btn);
    expect(screen.queryByTestId('toggle-element')).toBeInTheDocument();
    fireEvent.click(btn);
    expect(screen.queryByTestId('toggle-element')).toBeNull();
  });

  test('change input/ проверка связываемого инпута', () => {
    render(<App />);
    const input = screen.getByTestId('inputElement');
    expect(screen.getByTestId('div-element')).toContainHTML('');
    fireEvent.change(input, { target: { value: '2' } }); // вызываем событие change на input и передаем новое значение
    expect(input).toHaveValue('2');
    expect(screen.getByTestId('div-element')).toHaveTextContent('2');
  });
});

// Тестирование Router (помогает отслеживать изменения в маршруте)

import { MemoryRouter } from 'react-router-dom';

describe('Router', () => {
  test('Router test/ проверка маршрутизации', async () => {
    render(
      <MemoryRouter>
        <App />
      </MemoryRouter>,
    );
    const mainLink = screen.getByTestId('main-link');
    expect(mainLink).toBeInTheDocument();
    const aboutLink = screen.getByTestId('about-link');
    fireEvent.click(aboutLink);
    expect(aboutLink).toBeInTheDocument();
  });
});

test('check redirect to details page /проверка перехода на страницу с деталями', async () => {
  axios.get.mockResolvedValue(response);
  render(
    <MemoryRouter initialEntries={['/users']}>
      <Routes>
        <Route path="/users" element={<Users />} />
        <Route path="/users/:id" element={<UsersDetailsPage />} />
        <Users />
      </Routes>
    </MemoryRouter>,
  );
  const users = await screen.findAllByTestId('user-item');
  expect(users.length).toBe(3);
  //  expect(users[0]).toHaveAttribute('href', '/users/1');
  fireEvent.click(users[0]);
  expect(screen.getByTestId('user-page')).toBeInTheDocument();
  //  expect(window.location.pathname).toBe('/users/1');
});

// С созданием хелперов  и выноса render весь туда, также вынесли router в компонент AppRouter
renderWithRouter.js;

import { MemoryRouter } from 'react-router-dom';
import AppRouter from '../../router/AppRouter';
import { render } from '@testing-library/react';

export const renderWithRouter = (component, initialRoute = '/') => {
  return render(
    <MemoryRouter initialEntries={[initialRoute]}>
      <AppRouter />
      {component}
    </MemoryRouter>,
  );
};

Users.test.js;

test('check redirect to details page/ проверка перехода на страницу с деталями', async () => {
  axios.get.mockResolvedValue(response);
  // renderWithRouter(null, '/users');
  renderWithRouter(<Users />);
  const users = await screen.findAllByTestId('user-item');
  expect(users.length).toBe(3);
  //  expect(users[0]).toHaveAttribute('href', '/users/1');
  fireEvent.click(users[0]);
  expect(screen.getByTestId('user-page')).toBeInTheDocument();
  //  expect(window.location.pathname).toBe('/users/1');
});

// Тестируем Navbar , на нажатие на ссылку и переход на соответствующую страницу
describe('Test-Navbar', () => {
  test('main link/ переход на главную страницу', () => {
    renderWithRouter(<Navbar />);
    const mainLink = screen.getByTestId('main-link');
    fireEvent.click(mainLink);
    expect(screen.getByTestId('main-page')).toBeInTheDocument();
  });
  test('about link/ переход на страницу about', () => {
    renderWithRouter(<Navbar />);
    const aboutLink = screen.getByTestId('about-link');
    fireEvent.click(aboutLink);
    expect(screen.getByTestId('about-page')).toBeInTheDocument();
  });
  test('users link/ переход на страницу users', () => {
    renderWithRouter(<Navbar />);
    const userLink = screen.getByTestId('users-link');
    fireEvent.click(userLink);
    expect(screen.getByTestId('users-page')).toBeInTheDocument();
  });
});

// Тестирование redux toolkit

-проверка селекторов
-проверка редьюсеров

store.js;

export const store = configureStore({
  reducer: { counter: counterReducer },
  preloadedState: { counter: { value: 10000 } }, // начально значение
});

// Тестирование selectorov

import { selectValue } from './counterSelector';

describe('TEST selector', () => {
  test('Проверяем корректность работы селектора при пустом state', () => {
    expect(selectValue({})).toBe(0);
  });
  test('Проверяем корректность работы селектора при заполненном state', () => {
    expect(selectValue({ counter: { value: 10 } })).toBe(10);
  });
});

// Тестирование reducer

import counterSlice, { increment, decrement } from './counterSlice';

describe('TEST slice', () => {
  test('increment', () => {
    expect(counterSlice({ value: 0 }, increment())).toEqual({ value: 1 });
  });
  test('decrement', () => {
    expect(counterSlice({ value: 1 }, decrement())).toEqual({ value: 0 });
  });
  test('не передаем state', () => {
    expect(counterSlice(undefined, decrement())).toEqual({ value: -1 });
    expect(counterSlice(undefined, increment())).toEqual({ value: 1 });
  });
});

// Тетсирование redux

import { fireEvent, render, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import { createReduxStore } from '../../store/store';
import { renderWithRedux } from '../../tests/helpers/renderWithRedux';
import Counter from './Counter';
import { renderTestApp } from '../../tests/helpers/renderTestApp';

describe('Counter test', () => {
  test('increment button', async () => {
    render(
      // Благодоря функции createReduxStore() передаем начальное состояние
      <Provider store={createReduxStore({ counter: { value: 10 } })}>
        <Counter />
      </Provider>,
    );
    expect(screen.getByText('10')).toBeInTheDocument();
    fireEvent.click(screen.getByTestId('increment-btn'));
    expect(screen.getByTestId('value-title')).toHaveTextContent('11');
  });

  test('decrement button', async () => {
    // рендерим компонент с помощью renderWithRedux (helper)
    renderWithRedux(<Counter />, { counter: { value: 10 } });

    const decrementBtn = screen.getByTestId('decrement-btn');
    expect(decrementBtn).toBeInTheDocument();
    fireEvent.click(decrementBtn);
    expect(screen.getByTestId('value-title')).toHaveTextContent('9');
  });
  test('decrement button with redux', async () => {
    // рендерим компонент с помощью renderTestApp (helper) можем уазываеть путь и начальное состояние
    renderTestApp(null, {
      route: '/counter',
      initialState: { counter: { value: 10 } },
    });

    const decrementBtn = screen.getByTestId('decrement-btn');
    expect(decrementBtn).toBeInTheDocument();
    fireEvent.click(decrementBtn);
    expect(screen.getByTestId('value-title')).toHaveTextContent('9');
  });
});
```
